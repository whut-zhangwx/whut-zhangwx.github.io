<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++笔记 | 文羊羽</title><meta name="author" content="文羊羽"><meta name="copyright" content="文羊羽"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="课程简介 课程链接：C++教程 | c3程序员 老师主页：C3程序猿 参考教材：c++ primer plus by Stephen Prata C++官方文档：C++ reference">
<meta property="og:type" content="article">
<meta property="og:title" content="C++笔记">
<meta property="og:url" content="https://whut-zhangwx.github.io/cpp-notebook/index.html">
<meta property="og:site_name" content="文羊羽">
<meta property="og:description" content="课程简介 课程链接：C++教程 | c3程序员 老师主页：C3程序猿 参考教材：c++ primer plus by Stephen Prata C++官方文档：C++ reference">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://whut-zhangwx.github.io/white">
<meta property="article:published_time" content="2022-01-20T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-21T08:52:19.605Z">
<meta property="article:author" content="文羊羽">
<meta property="article:tag" content="计算机">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://whut-zhangwx.github.io/white"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://whut-zhangwx.github.io/cpp-notebook/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-21 16:52:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">89</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">文羊羽</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-20T16:00:00.000Z" title="发表于 2022-01-21 00:00:00">2022-01-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-21T08:52:19.605Z" title="更新于 2024-08-21 16:52:19">2024-08-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>130分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="课程简介">课程简介</h2>
<p>课程链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rW411R7g4">C++教程 | c3程序员</a></p>
<p>老师主页：<a target="_blank" rel="noopener" href="http://www.52c3.com/">C3程序猿</a></p>
<p>参考教材：<em>c++ primer plus</em> by Stephen Prata</p>
<p>C++官方文档：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp">C++ reference</a></p>
<span id="more"></span>
<h2 id="vscode环境搭建">VSCode环境搭建</h2>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/languages/cpp">C/C++ for Visual Studio Code</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nt4y1r7Ez">在VSCode搭建C/C++环境</a></p>
<ul>
<li>
<p>下载<a target="_blank" rel="noopener" href="https://nuwen.net/mingw.html">MinGW</a>安装并配置根目录下的<code>bin</code>文件夹路径<code>D:\MinGW\bin</code>到环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ --verison //用于检查是否安装配置成功</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>VSCode安装插件</p>
<ul>
<li>Code Runner</li>
<li>C/C++</li>
</ul>
</li>
<li>
<p>File&gt;Preference&gt;Settings&gt;搜索</p>
<ul>
<li>Run In Terminal: √Code-runner: Run In Terminal</li>
<li>Save File Before Run: √Code-runner: Save File Before Run</li>
<li>Auto Guess Encoding: √Files: Auto Guess Encoding</li>
</ul>
</li>
<li>
<p>中文乱码</p>
<ul>
<li>
<p>Code-runner: Language ID To File Extension Map<br>
<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1at4y1K7hx">VSCode防止C/C++中文乱码</a></p>
</li>
<li>
<p>控制台<br>
<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16G4y1t7hS">VSCode解决控制台乱码(一行命令)</a></p>
</li>
<li>
<p>設定vscode終端cmd、powshell、cmder編碼為utf-8<br>
<a target="_blank" rel="noopener" href="https://www.gushiciku.cn/pl/gfnx/zh-tw">設定vscode終端cmd、powshell、cmder編碼為utf-8</a></p>
</li>
<li>
<p>chcp</p>
<ul>
<li>65001: UTF-8</li>
<li>936: GBK</li>
</ul>
</li>
<li>
<p>强制输出UTF-8</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;chcp 65001&quot;</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>测试代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">//header files</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  <span class="comment">//function header</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;chcp 65001&quot;</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;Hello, 世界!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="use-vs-code-snippets-to-generate-main">Use VS Code snippets to generate main()</h2>
<p>File&gt;Preference&gt;Configure User Snippets&gt;cpp.json(C++)</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and </span></span><br><span class="line">  <span class="comment">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span></span><br><span class="line">  <span class="comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </span></span><br><span class="line">  <span class="comment">// same ids are connected.</span></span><br><span class="line">  <span class="comment">// Example:</span></span><br><span class="line">  <span class="attr">&quot;Print to console&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;snippet_main&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;#include &lt;iostream&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;using namespace std;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;int main()&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  &quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;  return 0;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;framework of main() for cpp&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Type in <strong>template_main</strong> (followed with shortcut <code>Ctrl+I</code> or <code>Ctrl+Space</code> to trigger focusSuggestion) then press <code>Enter</code> or <code>Tab</code> to make it work.</p>
</blockquote>
<h2 id="一段简单程序的输出-注释">一段简单程序的输出&amp;注释</h2>
<ul>
<li>
<p>hello world.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">//header files</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  <span class="comment">//function header</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="comment">//有些编译器(如VisualStudio)可能在运行程序后会自动关闭终端</span></span><br><span class="line"><span class="comment">//在return前使用这个命令可以阻止其立即关闭终端</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注释快捷键<br>
VS Code：<code>Ctrl</code>+<code>/</code></p>
</li>
<li>
<p>缩进快捷键</p>
<p>VS Code：<code>Ctrl</code>+<code>&#123;</code>/<code>&#125;</code></p>
</li>
</ul>
<h2 id="main-函数">main 函数</h2>
<h3 id="mian函数的一些特点">mian函数的一些特点</h3>
<ul>
<li>程序入口，由操作系统调用</li>
<li>一个项目<strong>要有且只能有</strong>一个main函数</li>
</ul>
<h3 id="mian函数的一些形式">mian函数的一些形式</h3>
<ul>
<li>
<p>c++标准形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>c标准形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一些其它形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命令行参数(c/c++) </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 旧标准c允许，c++不允许</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逻辑上符合，很多系统支持，少部分系统不支持（不提倡）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="main函数传参">main函数传参</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;argc = &quot;</span> &lt;&lt; argc &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;argc[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;] = &quot;</span> &lt;&lt; argv[i] &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~$ ./test</span><br><span class="line">argc = 1</span><br><span class="line">argv[0] = ./test</span><br><span class="line">~$ ./test s1 s2 s3</span><br><span class="line">argc = 4</span><br><span class="line">argv[0] = ./test</span><br><span class="line">argv[1] = s1</span><br><span class="line">argv[2] = s2</span><br><span class="line">argv[3] = s3</span><br></pre></td></tr></table></figure>
<h2 id="头文件">头文件</h2>
<ul>
<li>
<p>c++标准写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//i--input</span></span><br><span class="line"><span class="comment">//o--output</span></span><br><span class="line"><span class="comment">//stream -- information stream</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>c语言的标准写法（c++也支持）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">//c语言标准写法，c++也支持这种.h写法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="cout函数">cout函数</h2>
<ul>
<li>
<p>基本用法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; <span class="number">18</span> &lt;&lt; <span class="string">&quot;years old.&quot;</span>;</span><br><span class="line"><span class="comment">//连续输出，自动识别数据类型（printf需要指定数据类型）</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意点<br>
cout 是个对象，不是关键字，也不是函数</p>
</li>
</ul>
<h2 id="endl-n">endl&amp;’\n’</h2>
<ul>
<li>
<p>示范</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;  <span class="comment">//换行并清空缓冲区</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//换行</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>endl比’\n’多了一个刷新缓冲区的操作，这个操作会使缓冲区的字符立刻显示到屏幕上，’\n’则不保证这一点。</p>
</li>
<li>
<p>理论上，’\n’显示会比endl慢半拍，但实际使用中，两者基本没有区别。</p>
</li>
</ul>
<h2 id="cin函数">cin函数</h2>
<ul>
<li>
<p>基本用法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please input 3 integers: &quot;</span>;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br><span class="line"><span class="comment">// cin可以自动识别变量类型，比scanf更加智能（需要指定输入类型%d%c%s...）</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意点<br>
cin也是个对象，不是关键字，也不是函数</p>
</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<h3 id="数字类型">数字类型</h3>
<p><code>int</code> 类型为4个字节，32比特，存储范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[-2^{31},2^{31})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，即 -2147483648 到 2147483647。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span>; <span class="comment">// 4 bytes</span></span><br></pre></td></tr></table></figure>
<h3 id="常量类型">常量类型</h3>
<p>常量类型为只读类型的数据结构，其初始化后不能再被修改</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ZERO = <span class="number">0</span>;</span><br><span class="line">ZERO = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// error: assignment of read-only variable &#x27;ZERO&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="位运算">位运算</h3>
<p>与: <code>&amp;</code>, 或: <code>|</code>, 非: <code>~</code>, 异或: <code>^</code></p>
<h2 id="数组">数组</h2>
<h3 id="数组的初始化">数组的初始化</h3>
<ul>
<li>
<p>初始化列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intArray[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>等号可以省略</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intArray[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对部分元素初始化，其余默认为0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intArray[<span class="number">3</span>] &#123;<span class="number">1</span>&#125;; <span class="comment">// &#123;1, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化为0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intArray[<span class="number">3</span>] &#123;<span class="number">0</span>&#125;; <span class="comment">// &#123;0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化列表为空，默认所有元素初始化为0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intArray[<span class="number">3</span>] &#123;&#125;; <span class="comment">// &#123;0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不指定数组元素个数，由初始化列表决定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intArray[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="char-数组">char 数组</h3>
<p><code>std::cout</code>方法对字符数组的输出有特殊处理（重载），所以使用<code>cout</code>输出字符数组得到的是字符数组名的内容，而使用<code>cout</code>输出普通数组名得到的是数组的首地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> charGroup[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">cout &lt;&lt; charGroup &lt;&lt; endl;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> intGroup[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; intGroup &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 0xcb99dffbc0</span></span><br></pre></td></tr></table></figure>
<h3 id="数组名arr-数组名取地址-arr-数组首地址-arr-0">数组名arr、数组名取地址&amp;arr、数组首地址&amp;arr[0]</h3>
<ul>
<li>
<p>数组名arr<br>
数组名可以作为数组第一个元素的指针。由数组和指针的关系知道，arr代表这个地址的十六进制数值，它相当于一个指针，指向第一个元素(&amp;arr[0])，即指向数组的首地址。数组中的其他元素可以通过arr的位移(指针算术)得到，即 arr+i == &amp;a[i]。</p>
</li>
<li>
<p>数组名取地址&amp;arr<br>
对于一个普通的变量a，&amp;a是指用取地址符号取得变量a的内存地址；但是对于数组，arr在内存中并没有分配空间，只对数组arr的各个元素分配了存储空间，此处数组名字arr显然不是普通的变量，&amp;arr也不代表所取arr的存储地址，它其实是数组的首地址，sizeof(arr)表示的也是整个数组的字节数。</p>
</li>
<li>
<p>数组首地址&amp;arr[0]<br>
这个就是取地址的最直接的应用，相当于对普通变量取地址。arr[0]在内存中实际分类存储空间，而&amp;arr[0]就是取该存储空间的地址。同样对于任意满足范围的i，&amp;a[i]就是取第i个元素的存储地址。</p>
</li>
<li>
<p>动态数组指针</p>
<p>对于一个指向动态数组的指针pArr，&amp;pArr表示的是指针本身的地址，而pArr存储的是new出的动态数组的首地址，sizeof(pArr)表示的也是指针的字节数而非整个数组的字节数。并且通过new方法创建的动态数组是不能知道它的长度（大小/字节数）的，除非在创建时另外存储它的长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pArr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二维数组">二维数组</h3>
<ul>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> twoDim[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row=<span class="number">0</span>; row&lt;<span class="number">2</span>; row++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt;<span class="number">3</span>; col++)</span><br><span class="line">    cout &lt;&lt; twoDim[row][col] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 </span></span><br><span class="line"><span class="comment">// 4 5 6</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用指针访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> twoDim[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row=<span class="number">0</span>; row&lt;<span class="number">2</span>; row++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt;<span class="number">3</span>; col++)</span><br><span class="line">    cout &lt;&lt; *(*(twoDim + row) + col) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 </span></span><br><span class="line"><span class="comment">// 4 5 6</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二维数组在内存中连续存储<br>
从下面程序的输出结果可以看到二维数组的元素在空间中的存储地址是连续的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> twoDim[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row=<span class="number">0</span>; row&lt;<span class="number">2</span>; row++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt;<span class="number">3</span>; col++)</span><br><span class="line">    cout &lt;&lt; &amp;twoDim[row][col] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0x9ba9fff8a0 0x9ba9fff8a4 0x9ba9fff8a8 </span></span><br><span class="line"><span class="comment">// 0x9ba9fff8ac 0x9ba9fff8b0 0x9ba9fff8b4</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二维可以看成一个元素类型为数组的一维数组<br>
上面示例中的 <code>twoDim</code> 由2个整型数组构成，<code>twoDim[0]</code> 和 <code>twoDim[1]</code> 分别为它的第一个元素和第二个元素，它们的大小分别都是 <code>12=sizeof(int[3])</code>。</p>
<ul>
<li><code>twoDim</code>的指针算术±1将在地址上相差<code>12=sizeof(int[3])</code>个字节，即<code>twoDim+1</code>和<code>twoDim</code>相差12个bytes。</li>
<li><code>twoDim[0]</code>和<code>twoDim[1]</code>就是普通的一维数组，它们的指针算术±1将相差<code>4=sizeof(int)</code>个字节，即<code>twoDim[0]+1</code>和<code>twoDim[0]</code>相差4个bytes。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> twoDim[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(twoDim): &quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(twoDim) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;  <span class="string">&quot;twoDim: &quot;</span> &lt;&lt; twoDim &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="string">&quot;twoDim+1: &quot;</span> &lt;&lt; twoDim+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// sizeof(twoDim):  24</span></span><br><span class="line"><span class="comment">// twoDim: 0xa4bdbff680    twoDim+1: 0xa4bdbff68c</span></span><br><span class="line"><span class="comment">// (+12)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(twoDim[0]): &quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(twoDim[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;  <span class="string">&quot;twoDim[0]: &quot;</span> &lt;&lt; twoDim[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="string">&quot;twoDim[0]+1: &quot;</span> &lt;&lt; twoDim[<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// sizeof(twoDim[0]):  12</span></span><br><span class="line"><span class="comment">// twoDim[0]: 0xa4bdbff680 twoDim[0]+1: 0xa4bdbff684</span></span><br><span class="line"><span class="comment">// (+4)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(twoDim[1]): &quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(twoDim[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;  <span class="string">&quot;twoDim[1]: &quot;</span> &lt;&lt; twoDim[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="string">&quot;twoDim[1]+1: &quot;</span> &lt;&lt; twoDim[<span class="number">1</span>]+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// sizeof(twoDim[1]):  12</span></span><br><span class="line"><span class="comment">// twoDim[1]: 0xa4bdbff68c twoDim[1]+1: 0xa4bdbff690</span></span><br><span class="line"><span class="comment">// (+4)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二维数组→一维数组<br>
由于二维数组在内存中的地址是连续的，所以我们可以把二维数组看成一个一维数组，其中<code>twoDim[0]</code>或者<code>*twoDim</code>是这个一维数组的首地址。<br>
注意是<code>twoDim[0]</code>或者<code>*twoDim</code>，不是<code>twoDim</code>。虽然它们cout出的结果都是同一个十六进制地址，但是它们的指针算术不一样，<code>twoDim+1</code>将在地址上位移12个字节，<code>*twoDim+1</code>将在地址上位移4个字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> twoDim[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> idx=<span class="number">0</span>; idx&lt;<span class="number">2</span>*<span class="number">3</span>; idx++)</span><br><span class="line">  cout &lt;&lt; twoDim[<span class="number">0</span>][idx] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">// 1 2 3 4 5 6 </span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> idx=<span class="number">0</span>; idx&lt;<span class="number">2</span>*<span class="number">3</span>; idx++)</span><br><span class="line">  cout &lt;&lt; *(*twoDim + idx) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">// 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用迭代器遍历二维数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec = &#123;&#123;<span class="number">1</span>,<span class="number">10</span>&#125;, &#123;<span class="number">2</span>, <span class="number">20</span>&#125;, &#123;<span class="number">3</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter1=vec.<span class="built_in">begin</span>(); iter1!=vec.<span class="built_in">end</span>(); iter1++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> iter2=(*iter1).<span class="built_in">begin</span>(); iter2!=(*iter1).<span class="built_in">end</span>(); iter2++)&#123;</span><br><span class="line">    cout &lt;&lt; *iter2 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 10 </span></span><br><span class="line"><span class="comment">// 2 20</span></span><br><span class="line"><span class="comment">// 3 30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec = &#123;&#123;<span class="number">1</span>,<span class="number">10</span>&#125;, &#123;<span class="number">2</span>, <span class="number">20</span>&#125;, &#123;<span class="number">3</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=vec.<span class="built_in">begin</span>(); iter!=vec.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> num : *iter) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 10 </span></span><br><span class="line"><span class="comment">// 2 20</span></span><br><span class="line"><span class="comment">// 3 30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec = &#123;&#123;<span class="number">1</span>,<span class="number">10</span>&#125;, &#123;<span class="number">2</span>, <span class="number">20</span>&#125;, &#123;<span class="number">3</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=vec.<span class="built_in">begin</span>(); iter!=vec.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">  cout &lt;&lt; (*iter)[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*iter)[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 10 </span></span><br><span class="line"><span class="comment">// 2 20</span></span><br><span class="line"><span class="comment">// 3 30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec = &#123;&#123;<span class="number">1</span>,<span class="number">10</span>&#125;, &#123;<span class="number">2</span>, <span class="number">20</span>&#125;, &#123;<span class="number">3</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=vec.<span class="built_in">begin</span>(); iter!=vec.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec1 = *iter;</span><br><span class="line">  cout &lt;&lt; vec1[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec1[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 10 </span></span><br><span class="line"><span class="comment">// 2 20</span></span><br><span class="line"><span class="comment">// 3 30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec = &#123;&#123;<span class="number">1</span>,<span class="number">15</span>&#125;, &#123;<span class="number">2</span>, <span class="number">20</span>&#125;, &#123;<span class="number">3</span>, <span class="number">10</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; vec1 : vec)&#123;</span><br><span class="line">  cout &lt;&lt; vec1[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec1[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 10 </span></span><br><span class="line"><span class="comment">// 2 20</span></span><br><span class="line"><span class="comment">// 3 30</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>高维数组<br>
和二维数组同样的思路，在面对n维数组时，可以将n维数组看成一个元素是n-1维数组的一维数组。例如将3维数组看成一个元素是二维数组的一维数组。</p>
</li>
</ul>
<h3 id="动态二维数组">动态二维数组</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> row = <span class="number">2</span>, col = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 先创建一个指针的指针，指向一个指针数组</span></span><br><span class="line"><span class="type">int</span> **twoDim = <span class="keyword">new</span> <span class="type">int</span>* [row];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环new一组空间，将其首地址赋值给指针数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">  *(twoDim + i) = <span class="keyword">new</span> <span class="type">int</span>[col];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出动态数组元素的地址，注意不同行元素的地址不连续</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)</span><br><span class="line">    cout &lt;&lt; *(twoDim + i) + j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0x1ad45307ec0 0x1ad45307ec4 0x1ad45307ec8 </span></span><br><span class="line"><span class="comment">// 0x1ad45307f10 0x1ad45307f14 0x1ad45307f18</span></span><br></pre></td></tr></table></figure>
<h3 id="关于数组越界">关于数组越界</h3>
<p>C++不会对数组越界行为进行检查。（检查数组越界，编译器就必须在生成的目标代码中加入额外的代码用于程序运行时检测下标是否越界，这就会导致程序的运行速度下降）</p>
<p>不检查下标也为程序员提供了更大的操作空间，为指针操作带来更多的方便。C的数组标识符，里面并没有包含该数组长度的信息，只包含地址信息，所以语言本身无法检查，只能通过编译器检查，而早期的C语言编译器也不对数组越界进行检查，只能由程序员自己检查确保。</p>
<p>如果数组下标越界了，那么它会自动接着那块内存往后写。如果界外的空间暂时没有被利用，那么我们可以占用那块内存，但是如果界外的内存已经存放了东西，那么我们越界过去就会覆盖那块内存，则有可能会导致错误或是程序最终的运行结果出错，这些结果都是未知的。</p>
<h2 id="字符串">字符串</h2>
<h3 id="c风格字符串">C风格字符串</h3>
<h4 id="字符串的初始化">字符串的初始化</h4>
<ul>
<li>
<p>c风格字符串，结尾空字符<code>'\0'</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cString[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">cout &lt;&lt; cString &lt;&lt; endl; <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用字符串常量 <em>String Constant</em> (<strong>双</strong>引号引起的字符串<code>&quot;...&quot;</code>) 进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cString[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">cout &lt;&lt; cString &lt;&lt; endl; <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="字符常量-字符串常量">字符常量&amp;字符串常量</h4>
<ul>
<li>单引号引起的字符为<strong>字符常量</strong>，例如 <code>'a'</code>, <code>'A'</code>, <code>'\0'</code></li>
<li>双引号引起的字符为<strong>字符串常量</strong>，例如 <code>&quot;a&quot;</code>, <code>&quot;cat&quot;</code>, <code>&quot;zero&quot;</code></li>
</ul>
<p>其中 <code>&quot;a&quot; = &#123;'a', '\0'&#125;</code>，这是两者的区别</p>
<h4 id="拼接字符串">拼接字符串</h4>
<p>有时，字符串可能太长，无法方便地放在一行代码中。c++允许您连接字符串——也就是说，将两个带引号的字符串组合成一个字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cString[] = <span class="string">&quot;Sometimes a string may be too long to conveniently fit on one line of code.&quot;</span></span><br><span class="line"><span class="string">&quot; C++ enables you to concatenate string literals--that is, to combine two quoted strings into one.&quot;</span>;</span><br><span class="line">cout &lt;&lt; cString &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="strlen">strlen()</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> cString[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    cout &lt;&lt; cString &lt;&lt; endl; <span class="comment">// abc</span></span><br><span class="line">    <span class="comment">// strlen输出字符串的长度，不是数组的长度，不包含&#x27;\0&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(cString) &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// sizeof计算整个字符串数组的大小，包含&#x27;\0&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(cString) &lt;&lt; endl; <span class="comment">// 4 (bytes)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的读取">字符串的读取</h4>
<ul>
<li>
<p>直接使用 <code>cin &lt;&lt;</code>, 它会检测空白（空格，制表符，换行符）作为字符串结束标识，这样的会导致键入的字符串不能包含空格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Size = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> name[Size]; <span class="type">char</span> school[Size];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your name: &quot;</span>; cin &gt;&gt; name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your School: &quot;</span>; cin &gt;&gt; school;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\nName:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\tSchool: &quot;</span> &lt;&lt; school;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input your name: zhang wx</span></span><br><span class="line"><span class="comment">// Input your School:</span></span><br><span class="line"><span class="comment">// Name:zhang      School: wx</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>cin.getline()</code> 可以解决这个问题，它只检测换行作为字符串结束标识</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Size = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> name[Size]; <span class="type">char</span> school[Size];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your name: &quot;</span>; cin.<span class="built_in">getline</span>(name, Size);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your School: &quot;</span>; cin.<span class="built_in">getline</span>(school, Size);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\tSchool: &quot;</span> &lt;&lt; school;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input your name: zhang wx</span></span><br><span class="line"><span class="comment">// Input your School: whut</span></span><br><span class="line"><span class="comment">// Name:zhang wx   School: whut</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>cin.get()</code> 读取输入字符串时需要注意换行符<br>
<code>cin.get()</code> 的使用和 <code>cin.getline()</code> 类似，但是 <code>get()</code> 不是读取并丢弃换行符，而是将换行符留在输入队列中。如果连续两次调用 <code>cin.get()</code>，那么第二次 <code>cin.get()</code> 将会自动读取第一次输入结束的换行符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Size = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> name[Size]; <span class="type">char</span> school[Size];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your name: &quot;</span>; cin.<span class="built_in">get</span>(name, Size);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your School: &quot;</span>; cin.<span class="built_in">get</span>(school, Size); <span class="comment">// 第二次自动读取了换行符</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\tSchool: &quot;</span> &lt;&lt; school;</span><br><span class="line"><span class="comment">// Input your name: zhang wx</span></span><br><span class="line"><span class="comment">// Input your School: Name:zhang wx        School:</span></span><br></pre></td></tr></table></figure>
<p>使用不带参数的 <code>cin.get()</code> 可以处理这个问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Size = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> name[Size]; <span class="type">char</span> school[Size];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your name: &quot;</span>; cin.<span class="built_in">get</span>(name, Size);</span><br><span class="line">cin.<span class="built_in">get</span>(); <span class="comment">// 处理输出队列中的换行符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your School: &quot;</span>; cin.<span class="built_in">get</span>(school, Size);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\tSchool: &quot;</span> &lt;&lt; school;</span><br><span class="line"><span class="comment">// Input your name: zhang wx</span></span><br><span class="line"><span class="comment">// Input your School: whut</span></span><br><span class="line"><span class="comment">// Name:zhang wx   School: whut</span></span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name, Size); cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<p>可以连起来使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name, Size).<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为什么要使用get()，而不是getline()呢?<br>
首先，老式实现没有getline()。其次，get()使输入更仔细。例如，假设用get()将一行读入数组中。如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？查看下一个get()的输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。<br>
总之，getline()使用起来简单一些，但get()使得检查错误更简单些。可以用其中的任何一个来读取一行输入；只是应该知道，它们的行为稍有不同。</p>
</li>
<li>
<p>数字字符混合输入需要注意换行符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Size = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> age; <span class="type">char</span> name[Size];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your age: &quot;</span>; cin &gt;&gt; age;</span><br><span class="line">cin.<span class="built_in">get</span>(); <span class="comment">// 处理输出队列中的换行符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input your name: &quot;</span>; cin.<span class="built_in">get</span>(name, Size);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;\tName:&quot;</span> &lt;&lt; name;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; age; cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<p>可以连起来使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cin &gt;&gt; age).<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 std::getline() 可以读取带空格的输入并写入 string 类型的变量, 可以不使用 char[] 数组来表示字符串.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-类型">string 类型</h3>
<p>使用 string 类型需要在头文件中包含<code>&lt;string&gt;</code> 或者使用命名空间 <code>std</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Input your name: &quot;</span>; cin &gt;&gt; str;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your name: &quot;</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Input your name: zhang wx</span></span><br><span class="line"><span class="comment">// Your name: zhang</span></span><br></pre></td></tr></table></figure>
<p>直接使用 <code>cin &gt;&gt;</code> 读取输入字符串会以空字符作为输入结束标识，使用 <code>getlin(cin, str)</code> 读取字符串输入可以避免</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string name, school;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Input your name: &quot;</span>; <span class="built_in">getline</span>(cin, name);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Input your school: &quot;</span>; <span class="built_in">getline</span>(cin, school);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\tSchool: &quot;</span> &lt;&lt; school;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Input your name: zhang wx</span></span><br><span class="line"><span class="comment">// Input your school: whut</span></span><br><span class="line"><span class="comment">// Your name: zhang wx     School: whut</span></span><br></pre></td></tr></table></figure>
<p>string类的一些方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">str.<span class="built_in">pop_back</span>();</span><br><span class="line">str.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">if</span>(str.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str1=<span class="string">&quot;a&quot;</span>, str2=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">str.<span class="built_in">swap</span>(str2);</span><br></pre></td></tr></table></figure>
<h3 id="const-char-和-string">const char* 和 string</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// works</span></span><br><span class="line"><span class="type">const</span> string const_string = <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// works</span></span><br><span class="line">string &amp; string_ref= <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// doesn&#x27;t work</span></span><br><span class="line"><span class="comment">// a reference of type &quot;std::string &amp;&quot; (not const-qualified) cannot be initialized with a value of type &quot;const char</span></span><br><span class="line"><span class="type">const</span> string &amp; const_string_ref = <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// works</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> char_str_array[] = <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// works</span></span><br><span class="line"><span class="type">char</span>* char_str_point = <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// doesn&#x27;t work</span></span><br><span class="line"><span class="comment">// warning: ISO C++ forbids converting a string constant to &#x27;char*&#x27;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* const_char_str_point = <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// works</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> const_char_str = <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// dosen&#x27;t works</span></span><br><span class="line"><span class="comment">// a value of type &quot;const char *&quot; cannot be used to initialize an entity of type &quot;const char&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">returnString</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;helloworld&quot;</span>;&#125; <span class="comment">// works</span></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">returnConstString</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;helloworld&quot;</span>;&#125; <span class="comment">// works</span></span><br><span class="line"><span class="function">string &amp; <span class="title">returnStringReference</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;helloworld&quot;</span>;&#125; <span class="comment">// doesn&#x27;t work</span></span><br><span class="line"><span class="comment">// a reference of type &quot;std::string &amp;&quot; (not const-qualified) cannot be initialized with a value of type &quot;const char</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp; <span class="title">returnConstStringReference</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;helloworld&quot;</span>;&#125; <span class="comment">// doesn&#x27;t work</span></span><br><span class="line"><span class="comment">// warning: returning reference to temporary</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的比较">字符串的比较</h3>
<h4 id="c风格字符串的比较">C风格字符串的比较</h4>
<p>使用 <code>strcmp()</code> 需要引入头文件 <code>&lt;cstring&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;zhang&quot;</span>, str2[] = <span class="string">&quot;zhang&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">strcmp</span>(str1, str2); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是直接使用关系运算符比较C风格字符串，实际上比较的是它们的地址而非字符串本身的内容。例如下面代码中的两个字符串<code>str1</code>和<code>str2</code>拥有相同的内容，但是 <code>str1==str2</code> 却输出 <code>false</code>。因为比较的是<code>str1</code>和<code>str2</code>的首地址，两者的地址显然不相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;zhang&quot;</span>, str2[] = <span class="string">&quot;zhang&quot;</span>;</span><br><span class="line">cout &lt;&lt; boolalpha; <span class="comment">// 格式化bool输出</span></span><br><span class="line">cout &lt;&lt; (str1 == str2); <span class="comment">// false</span></span><br><span class="line">cout &lt;&lt; (<span class="built_in">strcmp</span>(str1, str2) == <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="string类型的比较">string类型的比较</h4>
<p>string 类型可以直接使用关系运算符 <code>==</code>、<code>!=</code> 进行比较（运算符重载）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;zhang&quot;</span>, str2 = <span class="string">&quot;zhang&quot;</span>;</span><br><span class="line">cout &lt;&lt; boolalpha; <span class="comment">// 格式化bool输出</span></span><br><span class="line">cout &lt;&lt; (str1 == str2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="char数组对中文字符的存储">char数组对中文字符的存储</h3>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/noonjuan/p/12319727.html">C语言 使用char字符实现汉字处理</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> str[] = <span class="string">&quot;你好，世界！Hello,World!&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> size = <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size = %d\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c%c\n&quot;</span>, str[<span class="number">0</span>], str[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(str[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(str[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c%c: %d, %d\n&quot;</span>, str[i], str[i+<span class="number">1</span>], str[i], str[i+<span class="number">1</span>]);</span><br><span class="line">      i += <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c: %d\n&quot;</span>, str[i], str[i]);</span><br><span class="line">      i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="struct-结构体">struct 结构体</h2>
<h3 id="c中的struct">C中的struct</h3>
<ul>
<li>
<p>C语言中定义结构体的格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  member-<span class="built_in">list</span></span><br><span class="line">  member-<span class="built_in">list</span></span><br><span class="line">  ...</span><br><span class="line">&#125; veriable-<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>  //<span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> a;   <span class="comment">//member-list</span></span><br><span class="line">  <span class="type">char</span> b;  <span class="comment">//member-list</span></span><br><span class="line">&#125; n1,n2;     <span class="comment">//variable-list</span></span><br><span class="line"><span class="comment">//声明了一个拥有2个成员的结构体</span></span><br><span class="line"><span class="comment">//结构体的标签是Node</span></span><br><span class="line"><span class="comment">//声明了2个结构体变量n1和n2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不注明标签</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>       //<span class="title">omit</span> <span class="title">the</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span> b;</span><br><span class="line">&#125; n1,n2;</span><br><span class="line"><span class="comment">//声明了一个拥有2个成员的结构体</span></span><br><span class="line"><span class="comment">//声明了2个结构体变量n1和n2</span></span><br><span class="line"><span class="comment">//此结构体没有注明标签</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不声明变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//声明了一个拥有两个成员的结构体</span></span><br><span class="line"><span class="comment">//结构体的标签为Node</span></span><br><span class="line"><span class="comment">//没有声明变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">n1</span>,<span class="title">n2</span>[10],*<span class="title">n3</span>;</span>  <span class="comment">//前面要加struct</span></span><br><span class="line"><span class="comment">//使用Node标签的结构体，声明变量n1,n2,n3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用typedef创建新的数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span> b;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="comment">//使用typedef创建新的数据类型Node</span></span><br><span class="line"></span><br><span class="line">Node n1,n2[<span class="number">10</span>],*n3;  <span class="comment">//前面不需要加struct</span></span><br><span class="line"><span class="comment">//使用新数据类型Node，声明变量n1,n2,n3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意</p>
<ul>
<li>c语言中，函数不能直接作为结构体的成员</li>
<li>当需要函数作为结构体成员时，需要借用<strong>函数指针</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">void</span> (*p)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">n1</span>=</span> &#123;<span class="number">1</span>, fun&#125;;  <span class="comment">//初始化结构体</span></span><br><span class="line">  n1.p();                   <span class="comment">//p中存放的是函数地址</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="c-中的struct">C++中的struct</h3>
<ul>
<li>C++中结构体的定义和C中几乎一样</li>
<li>C++中函数可以直接作为结构体成员</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  string name;              <span class="comment">// string 类型可以作为结构体成员</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span>;&#125; <span class="comment">// 函数可以作为结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// struct Student stu = &#123;18, &quot;zhang wx&quot;&#125;;</span></span><br><span class="line">  Student stu = &#123;<span class="number">18</span>, <span class="string">&quot;zhang wx&quot;</span>&#125;; <span class="comment">// 结构体实例化+初始化</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; stu.name &lt;&lt; endl; <span class="comment">// name: zhang wx</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; stu.age &lt;&lt; endl;   <span class="comment">// age: 18</span></span><br><span class="line">  stu.<span class="built_in">greet</span>(); <span class="comment">// Hello!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C中使用自定义的结构体类型实例化结构体变量时，需要在结构体名前加上<code>struct</code>关键字；但是在C++中<code>struct</code>可以省略，C++允许直接使用结构体名声明结构体变量，下面的两种实例化结构体的方法在C++中都是可行的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> stu = &#123;<span class="number">18</span>, <span class="string">&quot;zhang wx&quot;</span>&#125;; <span class="comment">// C and C++</span></span><br><span class="line">Student stu = &#123;<span class="number">18</span>, <span class="string">&quot;zhang wx&quot;</span>&#125;; <span class="comment">// C++</span></span><br></pre></td></tr></table></figure>
<h3 id="内部声明和外部声明">内部声明和外部声明</h3>
<p>结构声明的位置很重要。对于结构体而言，有两种选择：</p>
<ul>
<li>内部声明：将声明放在main()函数中；</li>
<li>外部声明：将声明放到main()的前面。</li>
</ul>
<p>外部声明可以被其后面的任何函数使用，而内部声明只能被该声明所属的函数使用。通常应使用外部声明，这样所有函数都可以使用这种类型的结构。</p>
<h3 id="typedef">typedef</h3>
<p>使用C++（和C）的关键字typedef来为类型创建别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> typeName aliasName;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>为char创建别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> byte;</span><br><span class="line">byte b = <span class="string">&#x27;b&#x27;</span>; <span class="comment">// aliasName</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// typeName</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为自定义数据类型（结构体）创建别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以分开写</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> Stu;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以合在一起</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  string name;</span><br><span class="line">&#125;Stu;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Stu stu1 = &#123;<span class="number">18</span>, <span class="string">&quot;zhang wx&quot;</span>&#125;;            <span class="comment">// aliasName</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Student</span> stu2 = &#123;<span class="number">18</span>, <span class="string">&quot;zhang wx&quot;</span>&#125;; <span class="comment">// typeNmae</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="结构体数组">结构体数组</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 声明结构体数组</span></span><br><span class="line">  <span class="comment">// 使用初始化列表初始化第一个结构体，其余默认为0和\0</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Student</span> stu[<span class="number">3</span>] = &#123;<span class="number">18</span>, <span class="string">&quot;zhang wx&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; stu[<span class="number">0</span>].name &lt;&lt; endl; <span class="comment">// name: zhang wx</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; stu[<span class="number">0</span>].age &lt;&lt; endl; <span class="comment">// age: 18</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; stu[<span class="number">1</span>].name &lt;&lt; endl; <span class="comment">// name:</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; stu[<span class="number">1</span>].age &lt;&lt; endl; <span class="comment">// age: 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体成员的访问">结构体成员的访问</h3>
<p><strong>结构体实例</strong>，使用<code>.</code>运算符访问结构体成员，例如下面的 <code>stu1.name</code> 和 <code>stu1.age</code><br>
<strong>结构体指针</strong>，可以先使用<code>*</code>运算符获得结构体实例再使用<code>.</code>运算符访问结构体成员，例如下面的 <code>(*stu2).name</code> 和 <code>(*sut2).age</code>；或者直接用<code>-&gt;</code>访问结构体成员，例如下面的 <code>stu2-&gt;name</code> 和 <code>sut2-&gt;age</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Student</span> stu1 = &#123;<span class="string">&quot;zhang wx&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; stu1.name &lt;&lt; endl; <span class="comment">// name: zhang wx</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; stu1.age &lt;&lt; endl; <span class="comment">// age: 18</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Student</span> *stu2 = &amp;stu1;</span><br><span class="line">  <span class="comment">// *</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; (*stu2).name &lt;&lt; endl; <span class="comment">// name: zhang wx</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; (*stu2).age &lt;&lt; endl; <span class="comment">// age: 18</span></span><br><span class="line">  <span class="comment">// -&gt;</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; stu2-&gt;name &lt;&lt; endl; <span class="comment">// name: zhang wx</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; stu2-&gt;age &lt;&lt; endl; <span class="comment">// age: 18</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="union-共用体">union 共用体</h2>
<p>共用体(union)是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。<br>
union在声明实例时会开辟一片内存，这个内存的大小为其定义里面最大数据类型的大小。当数据类型改变时，内存地址不变，不同的数据类型都会存储在这片内存中。<br>
共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。<br>
例如，假设管理一个小商品目录，其中有一些商品的ID为整数，而另一些的ID为字符串。</p>
<ul>
<li>在不使用union的情况下，结构体定义中需要声明两个成员，一个int类型(4bytes)，一个string类型(32bytes)，总共需要占用 32 + 4 = 36 (bytes)。并且在一个结构体实例中，总是会有其中一个成员的空间处于闲置状态；</li>
<li>但如果使用union，那么就可以将两种类型存储在同一片地址中，这样占用的空间大小就是 max(32, 4) = 32 (bytes)，如此可以节省空间占用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个union</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">numberUnion</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> intValue;</span><br><span class="line">  <span class="type">double</span> doubleValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个union实例</span></span><br><span class="line">  numberUnion n;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个union实例可以存储不同的数据类型，但同一时间只能存储一种类型</span></span><br><span class="line">  <span class="comment">// 在这个例子中 n 只有一块内存，既可以存储 int 类型，也可以存储 double 类型，但不能同时存储二者。</span></span><br><span class="line">  n.intValue = <span class="number">1</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;intValue: &quot;</span> &lt;&lt; n.intValue &lt;&lt; <span class="string">&quot;\tdoubleValue: &quot;</span> &lt;&lt; n.doubleValue &lt;&lt; endl;</span><br><span class="line">  n.doubleValue = <span class="number">1.0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;intValue: &quot;</span> &lt;&lt; n.intValue &lt;&lt; <span class="string">&quot;\tdoubleValue: &quot;</span> &lt;&lt; n.doubleValue &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// intValue: 1     doubleValue: 4.94066e-324</span></span><br><span class="line">  <span class="comment">// intValue: 0     doubleValue: 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------------------------------</span></span><br><span class="line">  <span class="comment">// 一个union实例的size是它能存储的最大类型的size，在这个例子中是 8bytes (double)</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof(n): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(n) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; endl</span><br><span class="line">       &lt;&lt; <span class="string">&quot;sizeof(n.intValue): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(n.intValue) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; endl</span><br><span class="line">       &lt;&lt; <span class="string">&quot;sizeof(n.doubleValue): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(n.doubleValue) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// sizeof(n): 8 bytes</span></span><br><span class="line">  <span class="comment">// sizeof(n.intValue): 4 bytes</span></span><br><span class="line">  <span class="comment">// sizeof(n.doubleValue): 8 bytes</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------------------------------</span></span><br><span class="line">  <span class="comment">// 声明一个union实例时开辟一个地址，不同类型的数据都存储在这个地址中</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;unionAddress: &quot;</span> &lt;&lt; &amp;n &lt;&lt; endl</span><br><span class="line">       &lt;&lt; <span class="string">&quot;intAddress: &quot;</span> &lt;&lt; &amp;n.intValue &lt;&lt; endl</span><br><span class="line">       &lt;&lt; <span class="string">&quot;doubleAddress: &quot;</span> &lt;&lt; &amp;n.doubleValue &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// unionAddress: 0x3f10fff988</span></span><br><span class="line">  <span class="comment">// intAddress: 0x3f10fff988</span></span><br><span class="line">  <span class="comment">// doubleAddress: 0x3f10fff988</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不同类型数据的内存地址相同</span></span><br><span class="line">  cout &lt;&lt; boolalpha; <span class="comment">// 格式化输出true(1)和false(0)</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;unionAddress == intAddress == doubleAddress: &quot;</span> </span><br><span class="line">       &lt;&lt; ((<span class="type">int</span>*)&amp;n == &amp;n.intValue &amp;&amp; (<span class="type">double</span>*)&amp;n == &amp;n.doubleValue) &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// unionAddress == intAddress == doubleAddress: true</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="enumerate-枚举">enumerate 枚举</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">spectrum</span>&#123;red, orange, yellow, green, blue, indigo, violet&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; red &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; orange &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; yellow &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; green</span><br><span class="line">      &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; blue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; indigo &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; violet &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">bits</span>&#123;one=<span class="number">0</span>, two=<span class="number">2</span>, four=<span class="number">4</span>, eight=<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="vector容器">vector容器</h2>
<ul>
<li>
<p>包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>vector的声明和初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v0;           <span class="comment">// 空的vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>)</span></span>;        <span class="comment">// size为5的vector，未初始化</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;     <span class="comment">// size为4的vector，初始化为1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 初始化为 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>size(): 返回vector对象中元素的个数</p>
</li>
<li>
<p>capacity(): 返回vector对象在内存中最大能够容纳的元素个数</p>
</li>
<li>
<p>assign(): 为vector对象重新赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="number">1</span>); <span class="comment">// 1 1 1 1 1</span></span><br><span class="line">v.<span class="built_in">assign</span>(&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;); <span class="comment">// 3 2 1 0</span></span><br><span class="line">v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>back(): 返回vector对象的末尾元素</p>
</li>
<li>
<p>front(): 返回vector对象的首元素</p>
</li>
<li>
<p>[index]: 使用中括号访问vector对象下标为index的元素</p>
</li>
<li>
<p>clear(): 清空vector对象中的元素</p>
</li>
<li>
<p>empty(): 判断vector对象是否为空，为空返回True，非空返回False</p>
</li>
<li>
<p>push_back(): 向vector对象末尾添加元素</p>
</li>
<li>
<p>pop_back(): 删除vector对象末尾的元素</p>
</li>
<li>
<p>begin(): 返回vector对象首元素的迭代器</p>
</li>
<li>
<p>end(): 返回vector对象末尾元素的迭代器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line"><span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); i++) cout &lt;&lt; *i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); i++) cout &lt;&lt; *i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sort(v.begin(), v.end()): 对v中从v.begin()（包括）到v.end()（不包括）的元素进行从小到大的排列</p>
</li>
<li>
<p>reverse(v.begin(), v.end()): 对v中从v.begin()（包括）到v.end()（不包括）的元素进行反转</p>
</li>
<li>
<p>find(v.begin(), v.end(), item): 在v中查找item，找到返回指向第一个item的迭代器，找不到返回v.end()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), item)!=v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="comment">//find the item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sort()，reverse()和find()方法都需要包含头文件<code>&lt;algorithm&gt;</code></p>
</blockquote>
</li>
</ul>
<h2 id="unordered-map">unordered_map</h2>
<p>unordered_map is an associated container that stores elements formed by the combination of a key value and a mapped value. The key value is used to uniquely identify the element and the mapped value is the content associated with the key. Both key and value can be of any type predefined or user-defined. In simple terms, an unordered_map is like a data structure of dictionary type that stores elements in itself. It contains successive pairs (key, value), which allows fast retrieval of an individual element based on its unique key.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个unordered_map对象</span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">umap[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">umap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;two&quot;</span>, <span class="number">2</span>&#125;);</span><br><span class="line">umap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;three&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断非空</span></span><br><span class="line"><span class="keyword">if</span> (umap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">  <span class="comment">// Empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : umap)</span><br><span class="line">  cout &lt;&lt; item.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter=umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); iter++)</span><br><span class="line">  cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">auto</span> iter = umap.<span class="built_in">find</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(iter != umap.<span class="built_in">end</span>())&#123;</span><br><span class="line">  cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针">指针</h2>
<h3 id="指针的使用">指针的使用</h3>
<ul>
<li>
<p>指向已经声明的变量的空间<br>
<code>&amp;</code> 为取地址运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var=<span class="number">0</span>; <span class="comment">// 声明int型的变量</span></span><br><span class="line"><span class="type">int</span> *p;    <span class="comment">// 声明int型指针</span></span><br><span class="line">p = &amp;var;  <span class="comment">// 将var的地址赋值给p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p中存放的是变量var的内存地址，以十六进制表示</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;    <span class="comment">// 0x4e0dfffe04</span></span><br><span class="line">cout &lt;&lt; &amp;var &lt;&lt; endl; <span class="comment">// 0x4e0dfffe04</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *p 对指针p所指向的内存进行操作</span></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// 写入数据</span></span><br><span class="line"><span class="comment">// var的值也随之改变</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p: &quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\tvar: &quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line"><span class="comment">// *p: 1   var: 1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开辟新的空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span> &#123;<span class="number">1</span>&#125;; <span class="comment">// 初始化为 1</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意下面的声明创建一个int型指针（p1）和一个int变量（p2):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1, p2;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组和指针">数组和指针</h3>
<p>C和C++内部都是使用指针来处理数组，所以数组和指针基本上是等价的，可以使用操作指针的方式 <code>*</code> 来操作数组，也可以使用操作数组的方式 <code>[]</code> 来操作指针</p>
<ul>
<li>
<p>使用 <code>*</code> 操作数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; p[<span class="number">1</span>] &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; *(p+<span class="number">1</span>) &lt;&lt; *(p+<span class="number">2</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>[]</code> 操作指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; *(p+<span class="number">1</span>) &lt;&lt; *(p+<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; p[<span class="number">1</span>] &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> [] p</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="静态数组和动态数组">静态数组和动态数组</h3>
<p>静态数组就是通常的数组，其内存在<strong>编译</strong>时分配，存储在栈上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>动态数组是由new或者malloc声明的数组，其内存在<strong>运行</strong>时分配，存储在堆上，而不是在编译时分配</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>动态数组允许你在声明时指定其长度，但是，C++ 没有提供改变此长度的内置方法。你可以通过申请新数组，复制需要的元素，然后删除旧数组的方式绕过这个限制。但是，这种方法已经被证明是容易出错的，尤其是当数组元素是class类型的时候（它们在被创建的时候受特殊的规则管理）。</p>
<p>因此，我们建议你不要这样做。</p>
<p>幸运的是，如果你需要这个功能，C++ 在标准库中提供名为 <code>std::vector</code> 的数据结构，它是一个可调整长度的数组。</p>
<h3 id="指针算术">指针算术</h3>
<p>将整数变量加1后，其值将增加1；但将指针变量加1后，增加的量等于它指向类型的字节数。将指向double的指针加1后，如果系统对double使用8个字节存储，则数值将增加8；将指向short的指针加1后，如果系统对short使用2个字节存储，则指针值将增加2。</p>
<ul>
<li>
<p>int 类型的指针 +1，其数值会 +4 —— sizeof(int)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 连续地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;(*p): &quot;</span> &lt;&lt; &amp;(*p) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;(*(p+1)): &quot;</span> &lt;&lt; &amp;(*(p+<span class="number">1</span>)) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;(*(p+2)): &quot;</span> &lt;&lt; &amp;(*(p+<span class="number">2</span>)) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// &amp;(*p): 0x5c4e1ffcf4</span></span><br><span class="line"><span class="comment">// &amp;(*(p+1)): 0x5c4e1ffcf8</span></span><br><span class="line"><span class="comment">// &amp;(*(p+2)): 0x5c4e1ffcfc</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>double 类型的指针 +1，其数值会 +8 —— sizeof(double)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> p[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 连续地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;(*p): &quot;</span> &lt;&lt; &amp;(*p) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;(*(p+1)): &quot;</span> &lt;&lt; &amp;(*(p+<span class="number">1</span>)) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;(*(p+2)): &quot;</span> &lt;&lt; &amp;(*(p+<span class="number">2</span>)) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// &amp;(*p): 0xfbb6dff6b0</span></span><br><span class="line"><span class="comment">// &amp;(*(p+1)): 0xfbb6dff6b8</span></span><br><span class="line"><span class="comment">// &amp;(*(p+2)): 0xfbb6dff6c0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="指针的大小">指针的大小</h3>
<p>指针大小是由当前CPU运行模式的寻址位数决定，在同一运行环境下不同类型指针的大小相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(char*): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>*) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(int*): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>*) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(double*): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>*) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// sizeof(char*): 8 bytes</span></span><br><span class="line"><span class="comment">// sizeof(int*): 8 bytes</span></span><br><span class="line"><span class="comment">// sizeof(double*): 8 bytes</span></span><br></pre></td></tr></table></figure>
<h3 id="星号的三种用法">* 星号的三种用法</h3>
<ul>
<li>
<p>用于声明指针变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>地址操作符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>表示乘法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>*<span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="void">void*</h3>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/void-pointer-c-cpp/">void Pointer in C</a></p>
<p>A void pointer is a pointer that has no associated data type with it. A void pointer can hold an address of any type and can be typecasted to any type.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>; <span class="type">double</span> d = <span class="number">1.0</span>;</span><br><span class="line">  <span class="type">void</span>* ptr;</span><br><span class="line">  ptr = &amp;i; <span class="comment">// void pointer holds address of int &#x27;i&#x27;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, *(<span class="type">int</span>*)ptr);</span><br><span class="line">  <span class="comment">// printf(&quot;i = %d&quot;, *ptr);</span></span><br><span class="line">  <span class="comment">// warning: dereferencing ‘void *’ pointer</span></span><br><span class="line">  <span class="comment">// error: invalid use of void expression</span></span><br><span class="line"></span><br><span class="line">  ptr = &amp;d; <span class="comment">// void pointer holds address of double &#x27;d&#x27;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;d = %f\n&quot;</span>, *(<span class="type">double</span>*)ptr);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>void*型指针在使用前需要进行类型转换。</p>
<h3 id="const-指针">const 指针</h3>
<p>顶层指针<br>
指针本身是const的（固定的），它指向的一个固定的内存空间，不能改变指针的指向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> ptr = &amp;a;</span><br><span class="line">*ptr = <span class="number">3</span>; <span class="comment">// ok</span></span><br><span class="line">ptr = &amp;b; <span class="comment">// error: assignment of read-only variable &#x27;ptr&#x27;</span></span><br></pre></td></tr></table></figure>
<p>底层指针<br>
指针所指向的空间的值是const的（只读的），不能通过指针来改变它所指向内存的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * ptr = &amp;a;</span><br><span class="line">ptr = &amp;b; <span class="comment">// ok</span></span><br><span class="line">*ptr = <span class="number">3</span>; <span class="comment">// error: assignment of read-only location &#x27;* ptr&#x27;</span></span><br></pre></td></tr></table></figure>
<p>指针使用指向一块固定空间的固定值，既不能改变指针的指向，也不能通过指针改变空间的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> ptr = &amp;a;</span><br><span class="line">ptr = &amp;b; <span class="comment">// error: assignment of read-only variable &#x27;ptr&#x27;</span></span><br><span class="line">*ptr = <span class="number">3</span>; <span class="comment">// error: assignment of read-only location &#x27;*(const int*)ptr&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="空间申请">空间申请</h2>
<h3 id="malloc和free的用法">malloc和free的用法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用malloc申请空间，返回一个指向该空间的地址，</span></span><br><span class="line"><span class="comment">// 并使用强制类型转换将地址的类型转换成(int*)型</span></span><br><span class="line"><span class="type">int</span> *p1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组: 连续空间的申请</span></span><br><span class="line"><span class="type">int</span> *p2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用malloc申请空间，需要使用free释放</span></span><br><span class="line"><span class="built_in">free</span>(p1);    <span class="comment">//单个和连续空间</span></span><br></pre></td></tr></table></figure>
<p>连续空间的初始化，使用memset函数需要加上头文件，且初始化的值只能是 0 或 -1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">memset</span>(p2, <span class="number">0</span>, <span class="number">5</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<h3 id="new和delete的用法">new和delete的用法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用new申请空间，返回一段空间的首地址</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//注意类型要匹配</span></span><br><span class="line"><span class="comment">// 数组: 连续空间的申请</span></span><br><span class="line"><span class="type">int</span> *p4 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]; <span class="comment">//new返回这段空间的首地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用new申请空间，需要使用delete释放</span></span><br><span class="line"><span class="keyword">delete</span> p3;   <span class="comment">//单个空间的释放</span></span><br><span class="line"><span class="keyword">delete</span>[] p4; <span class="comment">//连续空间的释放</span></span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用new申请空间的时候可以初始化</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="keyword">new</span> <span class="type">int</span> &#123;<span class="number">1</span>&#125;; <span class="comment">//初始化为1</span></span><br><span class="line"><span class="type">int</span> *p4 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//初始化列表</span></span><br></pre></td></tr></table></figure>
<h3 id="malloc和new的区别">malloc和new的区别</h3>
<ul>
<li>申请单个空间（包括数组和结构体）功能上没有区别</li>
<li>申请<strong>对象空间</strong>时
<ul>
<li>malloc只分配内存，不会进行初始化类成员的工作（调用构造函数），同样free 也不会调用析构函数；</li>
<li>new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数。</li>
</ul>
</li>
</ul>
<h2 id="模板类-vector-和-array">模板类 vector 和 array</h2>
<h2 id="引用">引用</h2>
<p>引用(Reference)类型是C++相对C新增的一种数据类型。引用就是给已经定义的变量起<strong>别名</strong>，其主要用途是用作函数的形参，使得函数可以更方便地（相对于指针）对原始变量本身进行操作，而不是只能对其拷贝进行修改。</p>
<h3 id="引用的声明">引用的声明</h3>
<ul>
<li>
<p>对普通变量的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref1 = var;  <span class="comment">// 声明变量var的一个引用</span></span><br><span class="line"><span class="type">int</span> &amp;ref2 = ref1; <span class="comment">// 可以声明引用的引用</span></span><br></pre></td></tr></table></figure>
<p>引用声明的时候就要初始化，否则会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref;</span><br><span class="line"><span class="comment">//  error: &#x27;ref&#x27; declared as reference but not initialized</span></span><br></pre></td></tr></table></figure>
<p>引用一旦声明就不能再作更改，后续对引用的操作都将等同于直接对变量做更改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var1 = <span class="number">0</span>, var2 = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;var1: &quot;</span> &lt;&lt; &amp;var1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;var2: &quot;</span> &lt;&lt; &amp;var2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var2 &lt;&lt; endl;</span><br><span class="line"><span class="comment">// &amp;var1: 0xe7193ff864 0</span></span><br><span class="line"><span class="comment">// &amp;var2: 0xe7193ff860 1</span></span><br><span class="line"><span class="type">int</span> &amp;ref = var1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;ref: &quot;</span> &lt;&lt; &amp;ref &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"><span class="comment">// &amp;ref: 0xe7193ff864 0</span></span><br><span class="line">     ref = var2; <span class="comment">// 这里并非如同指针一样将ref从var1重新指向var2</span></span><br><span class="line">                 <span class="comment">// 而是直接将var2的值赋给var1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;var1: &quot;</span> &lt;&lt; &amp;var1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;ref: &quot;</span> &lt;&lt; &amp;ref &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"><span class="comment">// &amp;var1: 0xe7193ff864 1</span></span><br><span class="line"><span class="comment">// &amp;ref: 0xe7193ff864 1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用的地址和被引用变量的地址完全一样，对引用的操作完全等同于对变量的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var;</span><br><span class="line"><span class="type">int</span> &amp;ref = var;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;var: &quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;ref: &quot;</span> &lt;&lt; &amp;ref &lt;&lt; endl;</span><br><span class="line"><span class="comment">// &amp;var: 0xeceafffbe4</span></span><br><span class="line"><span class="comment">// &amp;ref: 0xeceafffbe4</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常量的引用不能被赋值（因为常量本身不能被修改）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ONE = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref1 = ONE;</span><br><span class="line">ref1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// error: assignment of read-only reference &#x27;ref1&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref2 = <span class="number">2</span>;</span><br><span class="line">ref2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//  error: assignment of read-only reference &#x27;ref2&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数组的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (&amp;ref)[<span class="number">3</span>] = arr;</span><br><span class="line"><span class="comment">// 注意1：(&amp;ref)需要加()，否则根据运算符的优先级，就变成&amp;(ref[3])</span></span><br><span class="line"><span class="comment">// 注意2：[3]其中的3表示数组的大小，是数组类型的一部分，不能省略</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(ref)/<span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>当数组元素省略时<code>int &amp;ref[]</code>可以理解为引用的数组（注意区别于数组的引用），表示定义了一个数组，其中的元素是引用。但是这种用法在C++中是非法的，C++并没有规定引用的数组这一用法。</p>
</li>
<li>
<p>二维数组的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="built_in">int</span> (&amp;ref)[<span class="number">2</span>][<span class="number">3</span>] = arr;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结构体的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    string Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> stu;        <span class="comment">// 声明结构体变量 stu</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &amp;ref = stu; <span class="comment">// 声明结构体变量 stu 的引用 ref</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指针的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span> &#123;<span class="number">0</span>&#125;; <span class="comment">// 声明一个指针指向一个new空间，并初始化为0</span></span><br><span class="line"><span class="type">int</span>* &amp;ref = p;        <span class="comment">// 声明指针的一个引用</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;p: &quot;</span> &lt;&lt; &amp;p &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="string">&quot;*p: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;ref: &quot;</span> &lt;&lt; &amp;ref &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="string">&quot;ref: &quot;</span> &lt;&lt; ref &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="string">&quot;*ref: &quot;</span> &lt;&lt; *ref &lt;&lt; endl;</span><br><span class="line"><span class="comment">// &amp;p: 0x45a81ff6c0, p: 0x1abbc2d7ea0, *p: 0</span></span><br><span class="line"><span class="comment">// &amp;ref: 0x45a81ff6c0, ref: 0x1abbc2d7ea0, *ref: 0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="引用作参数">引用作参数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">intSquare</span><span class="params">(<span class="type">int</span> &amp;var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; &amp;var &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var &lt;&lt; endl; <span class="comment">// 0x711c3ffa6c 5</span></span><br><span class="line">  var = (var)*(var);</span><br><span class="line">  cout &lt;&lt; &amp;var &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var &lt;&lt; endl; <span class="comment">// 0x711c3ffa6c 25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  cout &lt;&lt; &amp;x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="comment">// 0x711c3ffa6c 5</span></span><br><span class="line">  <span class="built_in">intSquare</span>(x);</span><br><span class="line">  cout &lt;&lt; &amp;x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="comment">// 0x711c3ffa6c 25</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用作返回值">引用作返回值</h3>
<p><strong>不要引用局部变量</strong><br>
操作非法内存的结果是未知的。局部变量所占用的内存空间的分配和销毁，取决于编译器的实现，编译器为了优化程序的性能，可能有不同的策略来分配和释放内存。因此出了作用域的局部变量只是不允许访问了，但是该空间可能暂时没有被释放，你还是可以用指针去访问该空间。</p>
<ul>
<li>
<p>引用作返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">returnArg</span><span class="params">(<span class="type">int</span> var = <span class="number">0</span>)</span> </span>&#123; <span class="keyword">return</span> var; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> &amp;ref = <span class="built_in">returnArg</span>();</span><br><span class="line">  <span class="comment">// warning: reference to local variable &#x27;var&#x27; returned</span></span><br><span class="line">  cout &lt;&lt; ref &lt;&lt; endl; <span class="comment">// 读取了非法空间，结果不确定，取决于编译器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指针作返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">returnArg</span><span class="params">(<span class="type">int</span> var = <span class="number">0</span>)</span> </span>&#123; <span class="keyword">return</span> &amp;var; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> *p = <span class="built_in">returnArg</span>();</span><br><span class="line">  <span class="comment">// warning: address of local variable &#x27;var&#x27; returned</span></span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 读取了非法空间，结果不确定，取决于编译器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="引用与指针的区别">引用与指针的区别</h3>
<ul>
<li>引用必须初始化，指针可以不用初始化</li>
<li>引用声明后就不能引用其它空间了，指针可以指向其它空间</li>
<li>引用不占存储空间，指针占存储空间用于存放变量地址</li>
<li>引用效率更高，是对空间的直接访问，指针是间接访问</li>
<li>引用更安全，指针可以偏移<code>*(p+1)</code></li>
<li>引用只能在C++中使用；指针支持C和C++</li>
</ul>
<h3 id="交换两个变量的值">交换两个变量的值</h3>
<ul>
<li>
<p>使用引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp = a; a = b; b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// a=0, b=1</span></span><br><span class="line">  <span class="built_in">swapInt</span>(a, b); <span class="comment">// 传递引用</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// a=1, b=0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp = *a; *a = *b; *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// a=0, b=1</span></span><br><span class="line">  <span class="built_in">swapInt</span>(&amp;a, &amp;b); <span class="comment">// 传递地址</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// a=1, b=0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用swap函数<br>
swap()函数是c++内置的函数，包含在std中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// a=0, b=1</span></span><br><span class="line">  <span class="built_in">swap</span>(a, b);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// a=1, b=0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常量引用-read-only-reference">常量引用 read-only reference</h3>
<p>之前我们介绍过常量的引用，常量本身以及常量的引用在初始化之后都不能再被赋值修改，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">1</span>; <span class="comment">// error: assignment of read-only variable &#x27;i&#x27;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;</span><br><span class="line">r = <span class="number">2</span>; <span class="comment">// error: assignment of read-only reference &#x27;r&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但是常量引用不仅可以用于绑定常量，还可以用于绑定变量。这种用法产生的效果是变量本身还是可以被赋值修改，但变量的常量引用（read-only reference）却如同常量一样不能再被赋值修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">1</span>; <span class="comment">// works</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;</span><br><span class="line">r = <span class="number">2</span>; <span class="comment">// error: assignment of read-only reference &#x27;r&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="递增-递减-运算符">递增<code>++</code>递减<code>--</code>运算符</h2>
<p>要注意的是前递增(递减)和后递增(递减)</p>
<ul>
<li>
<p>递增运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">20</span>; <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;: b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a++ = &quot;</span> &lt;&lt; a++ &lt;&lt; <span class="string">&quot;: ++b = &quot;</span> &lt;&lt; ++b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;: b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// a = 20: b = 20</span></span><br><span class="line"><span class="comment">// a++ = 20: ++b = 21</span></span><br><span class="line"><span class="comment">// a = 21: b = 21</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>递减运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">20</span>; <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;: b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a-- = &quot;</span> &lt;&lt; a-- &lt;&lt; <span class="string">&quot;: --b = &quot;</span> &lt;&lt; --b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;: b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// a = 20: b = 20</span></span><br><span class="line"><span class="comment">// a-- = 20: --b = 19</span></span><br><span class="line"><span class="comment">// a = 19: b = 19</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>a++</code>（<code>a--</code>）是使用<code>a</code>当前的值参与表达式的计算，然后再将<code>a</code>的值加1（减1）<br>
<code>++b</code>（<code>--b</code>）是先将<code>b</code>的值加1（减1），然后再参与表达式的计算</p>
<h2 id="循环">循环</h2>
<h3 id="for-循环">for 循环</h3>
<ul>
<li>
<p>C++可以把变量的声明写在for()里面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>只有一条语句的时候<code>&#123;&#125;</code>可以省略</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">2</span>)</span><br><span class="line">  cout &lt;&lt; i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>,</code>逗号分割多个表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i+j&lt;<span class="number">10</span>; i+=<span class="number">2</span>, j++)</span><br><span class="line">  cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="while-循环">while 循环</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while-等待">while 等待</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> <span class="comment">// describes clock() function, clock_t type</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">float</span> secs=<span class="number">3.0</span>;</span><br><span class="line"><span class="type">clock_t</span> delay = secs * CLOCKS_PER_SEC; <span class="comment">// convert to clock ticks</span></span><br><span class="line"><span class="type">clock_t</span> start = <span class="built_in">clock</span>();               <span class="comment">// record the current time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">clock</span>() - start &lt; delay)        <span class="comment">// wait until time elapses</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">clock</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;done&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="for-while">for ⇔ while</h3>
<p>在C++中，for和while循环本质上是相同的，只是形式不同，它们可以相互转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-expression; test-expression; update-expression)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">statement</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init-expression;</span><br><span class="line"><span class="keyword">while</span> (test-expression)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">statement</span>(s)</span><br><span class="line">  update-expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-while-循环">do while 循环</h3>
<p>do while循环不同于for循环和while循环，因为它是出口条件 (exit condition）循环。这意味着这种循环将首先执行循环体，然后再判定测试表达式，决定是否应继续执行循环。如果条件为false，则循环终止；否则，进入新一轮的执行和测试。这样的循环通常<strong>至少执行一次</strong>，因为其程序流必须经过循环体后才能到达测试条件。下面是其句法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">  body</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">(test-expression)</span></span>;</span><br></pre></td></tr></table></figure>
<p>简单示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter numbers in the range 1-10&quot;</span></span><br><span class="line">        <span class="string">&quot;to find my favotire number:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">&#125; <span class="keyword">while</span> (n != <span class="number">7</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes, 7 is my favorite number.&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="基于范围的for循环-c-11">基于范围的for循环(C++11)</h3>
<p>C++11新增了一种循环：基于范围 (range-based) 的for循环。这种用法类似python的for循环，它简化了对数组/容器类的循环操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string fruits[] = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (string fruit : fruits)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; fruit &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// banana</span></span><br><span class="line"><span class="comment">// orange</span></span><br></pre></td></tr></table></figure>
<h3 id="break-和-continue">break 和 continue</h3>
<p>break: 跳过循环的其余部分，结束整个循环<br>
continue: 跳过循环体的其余部分，开始一个新的循环</p>
<ul>
<li>
<p>break</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">  cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>continue</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">  cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 3 4 </span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="分支语句">分支语句</h2>
<h3 id="if-else">if/else</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test-condition)</span><br><span class="line">  statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  statement2</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test-condition1)</span><br><span class="line">  <span class="function">statement1</span></span><br><span class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(test-condition2)</span></span></span><br><span class="line"><span class="function">  statement2</span></span><br><span class="line"><span class="function"><span class="keyword">else</span></span></span><br><span class="line"><span class="function">  statement3</span></span><br></pre></td></tr></table></figure>
<h3 id="条件运算符">条件运算符</h3>
<p>C++有一个常被用来代替if else语句的运算符，这个运算符被称为条件运算符<code>?:</code>，它是C++中唯一一个需要3个操作数的运算符。该运算符的通用格式如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 ? expression2 : expression3</span><br></pre></td></tr></table></figure>
<p>如果expressionl为true，则整个条件表达式的值为expression2的值；否则，整个表达式的值为expression3的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> &gt; <span class="number">3</span> ? <span class="number">10</span> : <span class="number">12</span> <span class="comment">// 5 &gt; 3 is true, so expression value is 10</span></span><br><span class="line"><span class="number">3</span> == <span class="number">9</span>? <span class="number">25</span> : <span class="number">18</span> <span class="comment">// 3 == 9 is false, so expression value is 18</span></span><br></pre></td></tr></table></figure>
<h3 id="switch">switch</h3>
<ul>
<li>
<p>范式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (integer-expression) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> label1 : <span class="built_in">statement</span>(s)</span><br><span class="line">  <span class="keyword">case</span> label2 : <span class="built_in">statement</span>(s)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>     : <span class="built_in">statement</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> idx;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input an integer: &quot;</span>;</span><br><span class="line">cin &gt;&gt; idx;</span><br><span class="line"><span class="keyword">switch</span> (idx%<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> : cout &lt;&lt; <span class="string">&quot;case 1&quot;</span> &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> : cout &lt;&lt; <span class="string">&quot;case 2&quot;</span> &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: cout &lt;&lt; <span class="string">&quot;default&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>switch + enum</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123;red, orange, yellow, green, blue&#125;;</span><br><span class="line"><span class="type">int</span> code;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter color code (0-4): &quot;</span>;</span><br><span class="line">cin &gt;&gt; code;</span><br><span class="line"><span class="keyword">switch</span> (code)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> red    : cout &lt;&lt; <span class="string">&quot;red&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> orange : cout &lt;&lt; <span class="string">&quot;orange&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> yellow : cout &lt;&lt; <span class="string">&quot;yellow&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> green  : cout &lt;&lt; <span class="string">&quot;green&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> blue   : cout &lt;&lt; <span class="string">&quot;blue&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: cout &lt;&lt; <span class="string">&quot;Out of range&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="逻辑运算符">逻辑运算符</h2>
<ul>
<li>
<p><code>&amp;&amp;</code>、<code>||</code>、<code>!</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">statement1 &amp;&amp; statement2 <span class="comment">// AND</span></span><br><span class="line">statement1 || statement2 <span class="comment">// OR</span></span><br><span class="line">!statement               <span class="comment">// NOT</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>and</code>、<code>or</code>、<code>not</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">statement1 <span class="keyword">and</span> statement2 <span class="comment">// AND</span></span><br><span class="line">statement1 <span class="keyword">or</span> statement2  <span class="comment">// OR</span></span><br><span class="line"><span class="keyword">not</span> statement             <span class="comment">// NOT</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果 AND 左侧语句为 false，则 C++ 将不会执行判断右侧的表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">a == <span class="number">0</span> &amp;&amp; cout &lt;&lt; a; <span class="comment">// 0</span></span><br><span class="line">a != <span class="number">0</span> &amp;&amp; cout &lt;&lt; a; <span class="comment">// Nothing</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果 OR 左侧语句为 true，则 C++ 将不会执行判断右侧的表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">a == <span class="number">0</span> || cout &lt;&lt; a; <span class="comment">// Nothing</span></span><br><span class="line">a != <span class="number">0</span> || cout &lt;&lt; a; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="cctype标准库">cctype标准库</h2>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/cctype">Standard library header &lt;cctype&gt; | cppreference</a></p>
<h2 id="文件的读取">文件的读取</h2>
<h2 id="函数">函数</h2>
<ul>
<li>
<p>没有返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">statement</span>(s)</span><br><span class="line">  <span class="keyword">return</span>;      <span class="comment">// optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>有返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">typeName <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  statements</span><br><span class="line">  <span class="keyword">return</span> value; <span class="comment">// value is type cast to type typeName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="函数声明-函数原型和函数定义">函数声明、函数原型和函数定义</h3>
<ul>
<li>
<p>函数声明（Declaration）<br>
函数声明是指把函数的名字、函数类型以及形参类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查。</p>
</li>
<li>
<p>函数原型（Prototyping）<br>
函数原型是函数声明中的一个特例，若要作为原型，函数声明还必须为函数的参数确定类型和标识符。函数原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型(如果有的话)以及参数的类型和数量告诉编译器。</p>
</li>
<li>
<p>函数定义（Definition）<br>
函数定义是指对函数功能的确立，包括指定函数名、函数值类型、形参类型、函数体等，它是一个完整的、独立的函数单位。只有带函数体的声明才叫函数定义。</p>
</li>
</ul>
<h3 id="函数传参">函数传参</h3>
<h4 id="按值传递">按值传递</h4>
<p>C++通常按值传递参数，这意味着将数值参数传递给函数，而函数将其赋给一个新的变量。即便两个变量同名，但它们依然不是同一个变量，它们的内存地址不相同，所以对两者值的修改不会影响到另一方的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coutAddress</span><span class="params">(<span class="type">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func_arg: &quot;</span> &lt;&lt; &amp;arg &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arg &lt;&lt; endl;</span><br><span class="line">  arg = <span class="number">1</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func_arg: &quot;</span> &lt;&lt; &amp;arg &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> arg = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;main_arg: &quot;</span> &lt;&lt; &amp;arg &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arg &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">coutAddress</span>(arg);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;main_arg: &quot;</span> &lt;&lt; &amp;arg &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arg &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main_arg: 0x47725ff98c 0</span></span><br><span class="line"><span class="comment">// func_arg: 0x47725ff960 0</span></span><br><span class="line"><span class="comment">// func_arg: 0x47725ff960 1</span></span><br><span class="line"><span class="comment">// main_arg: 0x47725ff98c 0</span></span><br></pre></td></tr></table></figure>
<p>注意上面程序的输出结果，mian()中的变量arg和函数coutAddress()中的变量arg，两者同名但内存地址不同。在coutAddress()中对arg进行修改不会影响到main()中的arg。</p>
<h4 id="传递地址">传递地址</h4>
<p>当给函数传递变量地址时，我们可以通过指针操作直接对内存进行修改，这样可以通过函数来修改main()中变量的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">intSquare</span><span class="params">(<span class="type">int</span>* var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *var = (*var)*(*var);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">intSquare</span>(&amp;x);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传递引用">传递引用</h4>
<p>当给函数传递变量引用时，我们也可以通过引用直接对内存进行修改，从而修改main()中变量的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">intSquare</span><span class="params">(<span class="type">int</span> &amp;var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; &amp;var &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var &lt;&lt; endl; <span class="comment">// 0x711c3ffa6c 5</span></span><br><span class="line">  var = (var)*(var);</span><br><span class="line">  cout &lt;&lt; &amp;var &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var &lt;&lt; endl; <span class="comment">// 0x711c3ffa6c 25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  cout &lt;&lt; &amp;x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="comment">// 0x711c3ffa6c 5</span></span><br><span class="line">  <span class="built_in">intSquare</span>(x);</span><br><span class="line">  cout &lt;&lt; &amp;x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="comment">// 0x711c3ffa6c 25</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传递数组">传递数组</h4>
<p>传递常规变量时，函数将使用该变量的值的拷贝；但传递数组时，函数对数组的操作将影响原来的数组。这是因为C++将数组视为指针，所以传递数组等价于传递指针。实际上，这种区别并不违反C++按值传递的方法，函数仍然传递了一个值，这个值被赋给一个新变量，但这个值是一个地址，而不是数组的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">squareArr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    arr[i] = arr[i] * arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> intArr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sizeof</span>(intArr)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i : intArr) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 1 2 3 </span></span><br><span class="line">  <span class="built_in">squareArr</span>(intArr, len); cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i : intArr) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 1 4 9</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数缺省值-默认参数">参数缺省值（默认参数）</h3>
<p>为函数参数指定默认值时，必须从右向左&lt;–连续指定。如果某个参数有默认值，那么它右边的所有参数都必须有默认值，否则会报错<code>error: default argument missing</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coutArgValues</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span> c = <span class="string">&#x27;b&#x27;</span>, <span class="type">float</span> f = <span class="number">3.14f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">coutArgValues</span>(<span class="number">1</span>); <span class="comment">// 1, b, 3.14</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coutArgValues</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b, <span class="type">float</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认参数可以放在函数声明或者定义中，但不能同时放在声明和定义中，只能放在二者之一，通常都会放在函数声明中。</p>
<h3 id="函数重载-函数多态">函数重载（函数多态）</h3>
<p>函数重载(Function Overloading)和函数多态(Function Polymorphism)是一回事。C++允许程序员使用不同的参数列表定义多个不同的<strong>同名函数</strong>，这是C++在C的基础上新增的功能。</p>
<h4 id="函数重载的定义">函数重载的定义</h4>
<p>在<strong>同一作用域内(公共作用域)</strong>，<strong>函数名相同</strong>并且<strong>参数列表不同</strong>的多个函数互为<strong>重载函数</strong>。</p>
<ul>
<li>Note1: 函数名字相同，但参数<strong>必须</strong>有所差别，否则会报错重定义。</li>
<li>Note2: 调用重载的函数，系统会根据传入参数的差别（类型、数量）自动调用对应的重载函数。</li>
<li>Note3: 重载函数的关键是参数列表的区别，在于参数的<strong>数目</strong>、<strong>类型</strong>和<strong>顺序</strong>，而参数变量名是无关紧要的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数重载，实现对输入参数类型的区分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coutArgType</span><span class="params">(<span class="type">float</span> f)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;float: &quot;</span> &lt;&lt; f &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coutArgType</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;double: &quot;</span> &lt;&lt; d &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">coutArgType</span>(<span class="number">3.14f</span>); <span class="comment">// float: 3.14</span></span><br><span class="line">  <span class="built_in">coutArgType</span>(<span class="number">3.14</span>);  <span class="comment">// double: 3.14</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>C++中的浮点数</strong><br>
当需要使用<code>float</code>类型时，需要在小数后面加上<code>f</code>，如<code>3.14f</code>、<code>2.71828f</code>；对于不加<code>f</code>的小数, C++默认其为<code>double</code>类型，这一点在函数重载时需要注意。</p>
</blockquote>
<h4 id="函数重载注意点">函数重载注意点</h4>
<ul>
<li>
<p><strong>同一作用域</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;   <span class="comment">//第1个函数的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">float</span> a)</span></span>&#123;&#125; <span class="comment">//第2个函数的定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> a)</span></span>&#123;&#125;  <span class="comment">//第3个函数的定义</span></span><br></pre></td></tr></table></figure>
<p>在主函数内(公共作用域)第1个函数和第2个函数互为重载函数，但不与第3个函数互为重载函数。<br>
函数声明会扩展函数的作用域，下面的程序中三个函数在主函数内互为重载函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;   <span class="comment">//第1个函数的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">float</span> a)</span></span>&#123;&#125; <span class="comment">//第2个函数的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> a)</span></span>;   <span class="comment">//第3个函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> a)</span></span>&#123;&#125;  <span class="comment">//第3个函数的定义</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>返回值不作为函数重载的条件</strong><br>
这两种声明方式会报重定义错误</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// cannot overload functions distinguished by return type aloneC/C++(311)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>函数重载时谨慎使用默认参数值</strong><br>
默认参数和函数重载结合使用，可能会造成调用不明确</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译通过, 运行报错</span></span><br><span class="line"><span class="comment">// error: call of overloaded &#x27;fun(int, int)&#x27; is ambiguous</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="函数的递归调用">函数的递归调用</h3>
<p>C++允许函数自己调用自己，这种功能被称为<strong>递归</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recurs</span><span class="params">(argumentlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">statements1</span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(test)</span></span></span><br><span class="line"><span class="function">    <span class="title">recurs</span><span class="params">(arguments)</span></span></span><br><span class="line"><span class="function">  statements2</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>斐波那契数列的递归实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">Fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">Fibonacci</span>(i) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数指针-函数作参数">函数指针（函数作参数）</h3>
<p>与数据项相似，函数也有地址。函数的地址是存储其<strong>机器语言代码</strong>的<strong>内存的起始地址</strong>。通常，这些地址对用户而言，既不重要，也没有什么用处，但对程序而言，却很有用。例如，可以编写将另一个函数的地址作为参数的函数。这样第一个函数将能够找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的时间传递不同函数的地址，这意味着可以在不同的时间使用不同的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n*n; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cube</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n*n*n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coutResult</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; (*pf)(n) &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// (*pf)等价于函数名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    <span class="built_in">coutResult</span>(i, square);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    <span class="built_in">coutResult</span>(i, cube);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数">内联函数</h3>
<p>内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。<br>
执行到普通函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈(为此保留的内存块)，跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中)，然后跳回到地址被保存的指令处。来回跳跃并记录跳跃位置意味着，使用函数时需要一定的时间开销。<br>
C++内联函数提供了另一种选择。内联函数的编译代码将被“内嵌”入其他程序的代码中。也就是说，编译器将使用相应的函数代码替换函数调用。但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。</p>
<p><img src="https://xiaophai-typora.oss-cn-shanghai.aliyuncs.com/inline-function-vs-regular-function.png" alt="inline-function-vs-regular-function"></p>
<p>上图对比了普通函数和内联函数在调用函数时的区别。左图为普通函数的示例，程序在main()中调用普通函数时会跳到其内存地址，执行函数的代码，在调用结束时再返回main()相应的位置。右图为内联函数的示例。在程序编译完成后，内联函数的代码被嵌入调用的位置，在执行时调用内联函数，程序不会在内存中来回跳动，而是直接线性地执行内联函数的代码。</p>
<p>在使用内联函数时需要在函数声明或者函数定义前加上关键字<code>inline</code>，通常的做法是省略函数原型，将整个定义放在本应提供原型的地方。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n*n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;^2 = &quot;</span> &lt;&lt; <span class="built_in">square</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot;^2 = &quot;</span> &lt;&lt; <span class="built_in">square</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot;^2 = &quot;</span> &lt;&lt; <span class="built_in">square</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意内联函数不能递归定义。</p>
</blockquote>
<h3 id="函数模板">函数模板</h3>
<p>如果需要将同一种函数（算法）用于不同类型的参数，除了使用函数重载，C++还新增了一种特性——函数模板。<br>
函数模板是通用的函数描述，它使用<strong>泛型</strong>（而不是具体类型）来定义函数，其中的泛型可用具体的类型（如int或double）替换。将具体类型的参数传递给<strong>模板函数</strong>，可使编译器生成该类型的<strong>具体函数</strong>。<br>
比如编写一个交换两个整型int类型变量的swap函数，这个函数就只能传入int型的变量，而无法处理double、char等这些类型，要实现这些类型的交换就要重新编写另一个swap函数，修改它的参数类型。而使用模板就可以让这个函数的实现与类型无关，比如一个swap模板函数，既可以实现对int型变量的交换，又可以实现对double、char等其它型变量的交换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapAnyType</span><span class="params">(AnyType &amp;a, AnyType &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AnyType temp = a; a = b; b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">swapAnyType</span>(i, j); <span class="comment">// 传递int类型变量的引用</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">swapAnyType</span>(x, y); <span class="comment">// 传递double类型变量的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的第一行指出，要建立一个模板，并将类型命名为<code>AnyType</code>。关键字 <code>template</code> 和 <code>typename</code> 是必需的。另外，必须使用尖括号 <code>&lt;&gt;</code> 。类型名可以任意选择(这里为<code>AnyType</code>)，只要遵守C++命名规则即可。余下的代码描述了交换两个 <code>AnyType</code> 类型变量的值。</p>
<p>在标准C++98添加关键字<code>typename</code>之前，C++使用关键字<code>class</code>来创建模板。也就是说，可以这样编写模板定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template &lt;typename AnyType&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">AnyType</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>typename</code>关键字使得参数<code>AnyType</code>表示类型这一点更为明显；然而，有大量代码库是使用关键字<code>class</code>开发的。在这种上下文中，这两个关键字是等价的。</p>
<p>注意，函数模板不能缩短可执行程序。对于上面的示例程序，最终结果仍将有两个独立的函数定义，一个int型参数，一个double型参数，就像以手动方式定义了这些函数一样。最终的代码不包含任何模板，而只包含了为程序生成的具体函数。使用模板的好处是，它让生成多个函数定义变得更简单方便、更可靠。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapAnyType</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp = a; a = b; b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapAnyType</span><span class="params">(<span class="type">double</span> &amp;a, <span class="type">double</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> temp = a; a = b; b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板重载">模板重载</h3>
<p>类似函数重载（多态），模板也可以重载，</p>
<h2 id="单独编译">单独编译</h2>
<p>C++允许甚至鼓励程序员将组件函数放在独立的文件中。可以单独编译这些文件，然后将它们链接成可执行的程序。</p>
<p>下面是一个比较两个整数大小的程序，它包含两个函数声明和两个函数定义，写在一个cpp文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">intMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">intMin</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Please enter two integers: &quot;</span>;</span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; i &gt;&gt; j)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The Max of them is : &quot;</span> &lt;&lt; <span class="built_in">intMax</span>(i, j) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The Min of them is : &quot;</span> &lt;&lt; <span class="built_in">intMin</span>(i, j) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Next two numbers (q to quit): &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Quit!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function definitions</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">intMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">intMin</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br></pre></td></tr></table></figure>
<p>我们将其拆成三个文件</p>
<ul>
<li>
<p>头文件: 包含函数的声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">intMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">intMin</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>源代码文件1: 包含main()函数（程序的入口）<br>
注意，在include头文件时，我们使用双引号<code>&quot;head.h&quot;</code>，而不是尖括号<code>&lt;head.h&gt;</code>。如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录(或其他目录，这取决于编译器)。如果没有在那里找到头文件，则将在标准位置查找。因此在包含自己的头文件时，应使用双引号而不是尖括号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span> <span class="comment">// intMax(), intMin()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Please enter two integers: &quot;</span>;</span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; i &gt;&gt; j)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The Max of them is : &quot;</span> &lt;&lt; <span class="built_in">intMax</span>(i, j) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The Min of them is : &quot;</span> &lt;&lt; <span class="built_in">intMin</span>(i, j) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Next two numbers (q to quit): &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Quit!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>源代码文件2：包含函数的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span> <span class="comment">// intMax(), intMin()</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">intMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">intMin</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在命令行中使用下面的命令对多文件进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compile</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">g++ -g .\file1.cpp .\file2.cpp -o multiFiles</span></span><br></pre></td></tr></table></figure>
<p>执行编译后的exe文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">execute</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">.\multiFiles</span></span><br></pre></td></tr></table></figure>
<h3 id="头文件">头文件</h3>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-header.html">理解 C++ 中的头文件和源文件的作用</a> &lt;-- 讲解得很详细</p>
<p>下面列出了头文件中常包含的内容。</p>
<ul>
<li>函数原型</li>
<li>使用 <code>#define</code> 或 <code>const</code> 定义的符号常量</li>
<li>结构声明</li>
<li>类声明</li>
<li>模板声明</li>
<li>内联函数</li>
</ul>
<p>将结构声明放在头文件中是可以的，因为它们不创建变量，而只是在源代码文件中声明结构变量时，告诉编译器如何创建该结构变量。同样，模板声明不是将被编译的代码，它们指示编译器如何生成与源代码中的函数调用相匹配的函数定义。被声明为const的数据和内联函数有特殊的链接属性（稍后将介绍），因此可以将其放在头文件中，而不会引起问题。</p>
<p><strong>尖括号和双引号</strong><br>
注意，在include自定义的头文件时，我们使用双引号<code>&quot;head.h&quot;</code>，而不是尖括号<code>&lt;head.h&gt;</code>。如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录(或其他目录，这取决于编译器)。如果没有在那里找到头文件，则将在标准位置查找。因此在包含自己的头文件时，应使用双引号而不是尖括号。</p>
<p><strong>请不要将函数定义或变量声明放到头文件中</strong>:</p>
<ul>
<li>在头文件中写函数的定义会导致重复定义的错误，如果这个头文件被多个源文件包含。因为每个源文件都会把头文件的内容复制过来，相当于在多个地方定义了同一个函数，这违反了单定义原则。除非函数是内联的，否则这将出错；</li>
<li>在头文件中写函数的定义会增加编译的时间，如果这个头文件被频繁修改。因为每次修改头文件后，所有包含这个头文件的源文件都需要重新编译，这对于大型项目来说非常耗时；</li>
<li>在头文件中写函数的定义会降低代码的可读性和可维护性，如果这个头文件包含了很多函数的定义。因为头文件的主要作用是提供函数的声明和接口，而不是实现细节。把函数的定义放在源文件中，可以让代码结构更清晰，也便于隐藏实现细节和保护数据。</li>
</ul>
<h3 id="防止头文件重复包含">防止头文件重复包含</h3>
<p><code>#include</code> 是一个来自 C 语言的宏命令，它在编译器进行编译之前，即在预编译的时候就会起作用。<code>#include</code> 的作用是把它后面所跟的那个 <code>.h</code> 文件的内容，完完整整地、一字不改地包含到当前的文件中来。值得一提的是，它本身是没有其它任何作用与副功能的，它的作用就是把每一个它出现的地方，替换成它后面所写的那个文件的内容。简单的文本替换，别无其他。</p>
<p>设想 <code>a.h</code> 中声明了 <code>class A</code> , <code>b.h</code> 中声明了 <code>class B</code>, 并且类 B 依赖类 A, 在 <code>b.h</code> 中还包含了a.h <code>#include a.h</code>. 此时我们在源文件中同时 <code>#include a.h</code> 和 <code>#include b.h</code> 会导致 <code>class A</code> 被包含了两次, 这样会报错重定义.</p>
<p>使用预处理器编译指令<code>#ifndef</code>(if not defined)，可以避免多次包含同一个头文件。下面的代码片段意味着仅当之前没有使用预处理器编译指令<code>#define</code>定义名称<code>COORDIN_H_</code>时，才处理<code>#ifindef</code>和<code>#endif</code>之间的语句:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COORDIN_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COORDIN_H_</span></span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>#ifndef</code>和<code>#endif</code>是标准的C/C++技术，它支持C和C++。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++中的方法</span></span><br><span class="line"><span class="meta">#program once </span></span><br><span class="line"><span class="comment">//这种写法非常方便, 但可能部分编译器不支持</span></span><br></pre></td></tr></table></figure>
<h3 id="全局变量和局部变量">全局变量和局部变量</h3>
<p>《C++ Primer Plus 第六版》 9.2 存储持续性、作用域和链接性</p>
<h2 id="编译和调试">编译和调试</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13K411M78v/">手把手教会VSCode的C++环境搭建，多文件编译，Cmake，json调试配置（Windows篇）</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/debugging">VSCode | User Guide | Debugging</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/variables-reference">VSCode | User Guide | Variables Reference</a></p>
</li>
</ul>
<p>本节的示例代码使用前面&quot;单独编译&quot;中示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">folder structure</span></span><br><span class="line">├── .vscode</span><br><span class="line">|   ├── launch.json</span><br><span class="line">|   └── tasks.json</span><br><span class="line">├── file.cpp</span><br><span class="line">└── files</span><br><span class="line">    ├── head.h</span><br><span class="line">    ├── file1.cpp (main)</span><br><span class="line">    └── file2.cpp</span><br></pre></td></tr></table></figure>
<h3 id="基于g-命令">基于g++命令</h3>
<ul>
<li>
<p>单文件编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compile</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">g++ -g .\file.cpp -o single_file.exe</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">execute</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">.\single_file.exe</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行<code>.exe</code>文件不要忘记在前面加<code>.\</code>，表示当前目录下<br>
其中的<code>-g</code>参数表示在编译时生成调试信息，该程序可以被调试器调试</p>
</blockquote>
</li>
<li>
<p>多文件编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compile</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">g++ -g .\file1.cpp .\file2.cpp -o multi_file</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">execute</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">.\multi_file</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>.exe</code> 可以省略</p>
</blockquote>
</li>
</ul>
<h3 id="基于launch-json和tasks-json">基于launch.json和tasks.json</h3>
<h4 id="单文件编译和调试">单文件编译和调试</h4>
<p><a target="_blank" rel="noopener" href="https://youtu.be/G9gnSGKYIg4?si=BdP61zbAb7HLn1zX">Debug a C++ project in VS Code</a></p>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/cpp/config-mingw">Using GCC with MinGW</a></p>
<p>Run &gt; Add Configuration<br>
&gt; Select environment: C++ (GDB/LLDB)<br>
&gt; Select a configuration: g++.exe - Build and debug active file</p>
<blockquote>
<p>You might need to downgrade the C/C++ extension to v1.8.4 since the latest version has some problems that it can not show the drop list for “g++.exe - Build and debug active file”.</p>
</blockquote>
<p>There will be a folder named .vscode in your workspace directory, which contains two files as following:</p>
<ul>
<li>
<p>.vscode\launch.json</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">  <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">  <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;g++.exe - Build and debug active file&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">      <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">      <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">      <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;D:\\MinGW\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">      <span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Set Disassembly Flavor to Intel&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: g++.exe build active file&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>.vscode\tasks.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>launch.json 是调试的配置文件</strong>：</p>
<ul>
<li>
<p>参数<code>&quot;program&quot;</code>的值为编译后的.exe文件的路径</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>$&#123;fileDirname&#125;</code>和<code>$&#123;fileBasenameNoExtension&#125;</code>是vscode的 <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/variables-reference">Predefined variables</a></p>
<ul>
<li><code>$&#123;fileDirname&#125;</code> - the current opened file’s folder path</li>
<li><code>$&#123;fileBasenameNoExtension&#125;</code> - the current opened file’s basename with no file extension</li>
<li><code>$&#123;fileWorkspaceFolder&#125;</code> - the current opened file’s workspace folder</li>
</ul>
<p><code>&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</code>表示一个与当前打开的cpp源代码文件的名称一致的exe文件，比如在当前打开的文件名为<code>myFile.cpp</code>的页面进行调试Run&gt;Start Debugging(F5)，那么默认的<code>&quot;program&quot;</code>所指向的就是<code>fileDirname</code>目录下的<code>myFile.exe</code>文件。</p>
<blockquote>
<p>之所以在launch.json中使用<code>&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</code>作为<code>&quot;program&quot;</code>的值，是因为在默认的task.json中的<code>g++.exe</code>命令的<code>-o</code>参数为<code>$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe</code>，其使用cpp源代码的文件名命名编译后的exe文件。当然也可以不这么做，而自行命名编译后的文件名称，只是这样自动命名会更方便。</p>
</blockquote>
</li>
<li>
<p>参数<code>&quot;cwd&quot;</code>表示&quot;current working directory&quot;，表示调试时的工作目录</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>参数 <code>&quot;preLaunchTask&quot;</code> 的值为 task.json 中一个 task 配置的label名。task规定了调试之前的编译工作，调用<code>g++</code>命令生成可执行的exe文件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// launch.json</span></span><br><span class="line"><span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe build active file&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tasks.json</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>也可以注释掉launch.json中的<code>&quot;preLaunchTask&quot;</code>，自行在终端使用<code>g++ -g ... -o ...</code>命令编译cpp文件，或者先运行一次源代码（程序会自动编译生成可执行exe文件），并指定<code>&quot;program&quot;</code>所指向的编译后的exe文件的路径。</p>
</li>
</ul>
<p><strong>tasks.json 用于在调试之前对cpp文件重新进行编译，生成可以执行和调试的exe文件</strong>：</p>
<ul>
<li>
<p>参数<code>&quot;command&quot;</code>和<code>&quot;args&quot;</code>指定了需要调用的命令以及附加的参数</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p><code>$&#123;file&#125;</code>是vscode的 <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/variables-reference">Predefined variables</a> 表示当前打开的文件</p>
<blockquote>
<p>其中<code>g++</code>命令<code>&quot;-o&quot;</code>参数的值和 launch.json 中<code>&quot;program&quot;</code>参数的值一致，都是<code>&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</code>，<code>-o</code>参数指定项目编译后生成的文件名，使用vscode的保留字规定了编译后的exe文件名和源代码cpp文件的名称一致。</p>
</blockquote>
</li>
<li>
<p>参数<code>&quot;label&quot;</code>为一个task配置的标签，launch.json中参数<code>&quot;preLaunchTask&quot;</code>的值就是task的标签，标签唯一标识一个task的配置。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// launch.json</span></span><br><span class="line"><span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe build active file&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tasks.json</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe build active file&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="多文件编译和调试">多文件编译和调试</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">folder structure</span></span><br><span class="line">├── .vscode</span><br><span class="line">|   ├── launch.json</span><br><span class="line">|   └── tasks.json</span><br><span class="line">├── file.cpp</span><br><span class="line">└── files</span><br><span class="line">    ├── head.h</span><br><span class="line">    ├── file1.cpp (main)</span><br><span class="line">    └── file2.cpp</span><br></pre></td></tr></table></figure>
<p>针对多文件的调试，我们需要修改task.json中<code>g++</code>的<code>-g</code>参数，将原本的<code>$&#123;file&#125;</code>(当前打开的cpp文件)修改为多个文件。也可以修改<code>-o</code>参数，设置输出编译后exe文件的路径和名称</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .vscode\tasks.json</span></span><br><span class="line"><span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// &quot;$&#123;file&#125;&quot;,</span></span><br><span class="line">      <span class="string">&quot;$&#123;fileWorkspaceFolder&#125;\\files\\file1.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;$&#123;fileWorkspaceFolder&#125;\\files\\file2.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">      <span class="string">&quot;$&#123;fileWorkspaceFolder&#125;\\files\\multiFiles.exe&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>其中多个cpp文件可以用<code>*.cpp</code>来代替，这样更方便</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;$&#123;fileWorkspaceFolder&#125;\\files\\file1.cpp&quot;,</span></span><br><span class="line"><span class="comment">// &quot;$&#123;fileWorkspaceFolder&#125;\\files\\file2.cpp&quot;,</span></span><br><span class="line"><span class="string">&quot;$&#123;fileWorkspaceFolder&#125;\\files\\*.cpp&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>使用<code>$&#123;fileDirname&#125;</code>可以方便定位到文件所在目录</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;$&#123;fileDirname&#125;\\*.cpp&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>一个通用的task.json中args可以这样配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;$&#123;fileDirname&#125;\\*.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p><code>-g $&#123;fileDirname&#125;\\*.cpp</code>表示共同编译当前打开的文件所在目录的所有cpp文件；<code>-o $&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe</code>表示在当前打开的文件所在目录输出与当前打开文件同名的exe文件。</p>
<p>如果在tasks.json中修改了<code>g++</code>的<code>-o</code>参数，则需要同时修改launch.json的<code>&quot;program&quot;</code>指向编译后的文件路径</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .vscode\launch.json</span></span><br><span class="line"><span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br></pre></td></tr></table></figure>
<p>配置好launch.json和task.json后，在Vscod左侧的Run and Debug栏中选择对应的launch配置的名称，这个例子里面launch配置的名称为&quot;g++.exe - Build and debug active file&quot;，然后进行调试Run&gt;Start Debugging(F5)。</p>
<h4 id="predefined-variables-reference">Predefined Variables Reference</h4>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/variables-reference">Predefined variables</a></p>
<h3 id="c-编译流程">C++编译流程</h3>
<p>预处理 Preprocess - 编译 Compile - 汇编 Assemble - 链接 linking</p>
<ul>
<li>
<p>预处理: 在这个阶段主要做了三件事: 展开头文件 、宏替换 、去掉注释行<br>
这个阶段需要GCC调用<strong>预处理器</strong>来完成, 最终得到的还是源文件, 文本格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E ./helloworld.cpp -o ./helloworld.i # 预处理, 调用 cc1plus 命令</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译: 这个阶段需要GCC调用<strong>编译器</strong>对文件进行编译, 最终得到一个汇编文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S ./helloworld.i -o ./helloworld.s   # 编译, 调用 cc1plus 命令</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>汇编: 这个阶段需要GCC调用<strong>汇编器</strong>对文件进行汇编, 最终得到一个二进制文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c ./helloworld.s -o ./helloworld.o   # 汇编, 调用 as 命令</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>链接: 这个阶段需要GCC调用<strong>链接器</strong>对程序需要调用的库进行链接, 最终得到一个可执行的二进制文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ ./helloworld.o -o ./helloworld.out    # 链接, 调用 ld 命令</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后执行程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./helloworld.out # 执行</span><br><span class="line">hello, world!</span><br></pre></td></tr></table></figure>
<p>上面的所有步骤可以使用一次命令完成</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ ./helloworld.cpp -o ./helloworld # (预处理+编译+汇编)链接-&gt;可执行文件</span><br></pre></td></tr></table></figure>
<p>上述是单个文件编译生成可执行文件的过程, 对于多个文件也是类似的过程. 先编译生成二进制的动态链接库或者静态链接库, 再将多个 <code>.o</code>, <code>.so</code> 文件进行链接生成可执行文件</p>
<pre class="mermaid">graph LR
a.cpp --"preprocess"--> a.i --"compile"--> a.s --"assemble"--> a.o --> ld(("link"))
b.cpp --"preprocess"--> b.i --"compile"--> b.s --"assemble"--> b.o --> ld(("link"))
c.cpp --"preprocess"--> c.i --"compile"--> c.s --"assemble"--> c.o --> ld(("link"))
ld --> abc.out</pre>
<p>另外并不是只能使用 g++ 编译 c++ 文件, 只能使用 gcc 编译 c 文件. 事实上 gcc 也可以编译 c++ 文件. 使用 gcc 编译 cpp 文件需要加参数 <code>-l stdc++</code>, 表示在<strong>链接时</strong>指定使用 C++ 的动态链接库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ./helloworld.cpp -o ./helloworld -l stdc++</span><br></pre></td></tr></table></figure>
<h2 id="namespace">namespace</h2>
<h3 id="命名空间的创建">命名空间的创建</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建命名空间stu1，包含函数func和func1</span></span><br><span class="line"><span class="keyword">namespace</span> stu1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;stu1::func&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;stu1::func1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建命名空间stu2，包含函数func和func2</span></span><br><span class="line"><span class="keyword">namespace</span> stu2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;stu2::func&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;stu2::func2&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名空间的使用">命名空间的使用</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用using指令来打开对应的命名空间，这样就可以直接在main函数中调用命名空间中的函数</span></span><br><span class="line"><span class="comment">//注意这两个语句必须放在两个命名空间stu1和stu2的定义之后，否则会报错</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> stu1;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> stu2;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用作用域运算符::来调用命名空间中的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当两个命名空间中包含同名函数时，可以用::来调用指定命名空间的函数</span></span><br><span class="line">    stu1::<span class="built_in">func</span>();</span><br><span class="line">    stu2::<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//可以不用using指令打开命名空间std，直接使用::调用其中的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;scope operator::&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类和对象">类和对象</h2>
<h3 id="类和对象的声明">类和对象的声明</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 数据成员</span></span><br><span class="line">  <span class="type">int</span> id_;</span><br><span class="line">  string name_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 函数成员（方法）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; id_ = id; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123; name_ = name; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id_; &#125;</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu;</span><br><span class="line">  stu.<span class="built_in">setId</span>(<span class="number">1000</span>);</span><br><span class="line">  stu.<span class="built_in">setName</span>(<span class="string">&quot;zhangwx&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Id: &quot;</span> &lt;&lt; stu.<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; stu.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类成员的访问">类成员的访问<code>.</code>&amp;<code>-&gt;</code></h3>
<p>类的成员需要通过对象才能访问，不能直接通过类名访问</p>
<p><strong>类对象</strong>，使用<code>.</code>运算符访问结构体成员，例如下面的 <code>stu1.setId()</code>、<code>stu1.getId()</code>等。<br>
<strong>类指针</strong>，可以直接用<code>-&gt;</code>访问结构体成员，例如下面的 <code>stu2-&gt;setId()</code>和 <code>stu2-&gt;getId()</code>；<br>
或者先使用<code>*</code>运算符获得结构体实例再使用<code>.</code>运算符访问结构体成员，例如下面的 <code>(*stu2).setName()</code>和<code>(*stu2).getName()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类对象</span></span><br><span class="line">CStu stu1;</span><br><span class="line">stu1.<span class="built_in">setId</span>(<span class="number">1001</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Id: &quot;</span> &lt;&lt; stu1.<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line">stu1.<span class="built_in">setName</span>(<span class="string">&quot;zhangwx&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; stu1.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 类指针</span></span><br><span class="line">CStu *stu2 = <span class="keyword">new</span> CStu;</span><br><span class="line">stu2-&gt;<span class="built_in">setId</span>(<span class="number">1002</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Id: &quot;</span> &lt;&lt; stu2-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line">(*stu2).<span class="built_in">setName</span>(<span class="string">&quot;xiaophai&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; (*stu2).<span class="built_in">getName</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="const函数成员">const函数成员</h3>
<p>在类的成员方法声明后面加上const关键字，表示这个类方法是read-only的，它只能读取而不能修改类的数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string name_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123; name_ = name; &#125;</span><br><span class="line">  <span class="comment">// const方法不能对类的数据成员进行修改，它是read-only的</span></span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<ul>
<li>
<p>const只能加在<strong>非静态成员函数</strong>后面<br>
如果加到普通函数(非成员函数)后面会报错 a type qualifier is not allowed on a nonmember function，如果放到静态成员函数后面会报错 a type qualifier is not allowed on a static member function</p>
</li>
<li>
<p>使用 const 限定符的函数成员，其传入的this指针是const的，所以不能通过它修改类的成员（const指针是只读的）</p>
</li>
</ul>
<h3 id="访问修饰符public-private">访问修饰符public&amp;private</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> name;   <span class="comment">// 私有数据成员（默认）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="comment">// 公有函数成员</span></span></span><br><span class="line"><span class="function">  </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> <span class="comment">// 私有函数成员</span></span></span><br><span class="line"><span class="function">  </span>&#123; ... &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//public:使类成员对外可见</span></span><br><span class="line"><span class="comment">//private:成员类内可见,类外不可见</span></span><br><span class="line"><span class="comment">//默认是private:</span></span><br></pre></td></tr></table></figure>
<ul>
<li>访问修饰符可以用于类内成员的分类，使得代码更加清晰</li>
<li>类默认的访问修饰符是<code>private:</code>，结构体默认的是<code>public:</code></li>
</ul>
<p><strong>类和结构体</strong><br>
类描述看上去很像是包含成员函数以及public和private可见性标签的结构体声明。实际上，C++对结构体进行了扩展，使之具有与类相同的特性（函数可以作为结构体成员）。<strong>它们之间唯一的区别是，结构体的默认访问类型是public，而类为private</strong>。C++程序员通常使用类来实现类描述，而把结构体限制为只表示纯粹的数据对象（常被称为普通老式数据（POD，Plain Old Data）结构）。</p>
<h3 id="访问修饰符protected">访问修饰符protected</h3>
<p><code>protected:</code>对类外不可见，对类内和类的子类可见</p>
<h3 id="构造函数constructor">构造函数constructor</h3>
<ul>
<li>
<p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行；<br>
构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void；<br>
构造函数用于对类成员进行初始化，或者进行一些其它操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数(与类同名)</span></span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> age, string name)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用接口函数访问私有成员</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu = &#123;<span class="number">18</span>, <span class="string">&quot;zhangwx&quot;</span>&#125;;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; stu.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; stu.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造函数在对象定义时被调用</p>
<ul>
<li>栈区对象(变量对象), 在定义时调用构造函数</li>
<li>堆区对象(指针对象), 在声明指针的时候不会调用, new空间的时候调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CStu *stu;       <span class="comment">// 声明指针时不调用</span></span><br><span class="line">stu = <span class="keyword">new</span> CStu;  <span class="comment">// 此处调用构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>系统默认构造函数<br>
一个类除了用户自定义的构造函数，还有一个系统默认的构造函数。系统默认的构造函数是个空函数，什么都不做。只要宏观声明构造函数之后，系统默认的构造函数就被“覆盖”了。</p>
</li>
</ul>
<h3 id="类内声明-内外定义">类内声明+内外定义</h3>
<p>可以将类的成员函数的定义放在类外，类内只要函数声明。<br>
类外定义成员函数需要加上类名并使用作用域运算符<code>::</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 函数声明</span></span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> age);</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu = &#123;<span class="number">18</span>&#125;;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; stu.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line">CStu::<span class="built_in">CStu</span>(<span class="type">int</span> age) &#123;<span class="keyword">this</span>-&gt;age = age;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CStu::getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br></pre></td></tr></table></figure>
<p>当将类的声明放在头文件中时需要这么做，在头文件中类内声明成员函数（包括构造和解析函数），在另外的文件中定义类的成员函数。</p>
<ul>
<li>类内声明类外定义的意义在于多文件，将函数声明写在头文件，定义写在源文件中。</li>
<li>当只有一个文件的时候没必要将类成员函数的定义写在类外。</li>
</ul>
<h3 id="初始化列表">初始化列表</h3>
<p>与其他函数不同，构造函数除了有名字，参数列表和函数体之外，还可以有初始化列表，初始化列表以冒号开头，后跟一系列以逗号分隔的初始化字段。</p>
<ul>
<li>
<p>普通变量使用初始化列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> age_;     <span class="comment">// 后缀下划线表示私有成员</span></span><br><span class="line">  string name_; <span class="comment">// 并与正常的变量区分造成歧义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数                // 初始化列表</span></span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> age, string name) : <span class="built_in">age_</span>(age), <span class="built_in">name_</span>(name)</span><br><span class="line">  &#123; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu = &#123;<span class="number">18</span>, <span class="string">&quot;zhangwx&quot;</span>&#125;;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; stu.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; stu.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数组成员使用初始化列表<br>
并非所有的编译器都支持数组的初始化列表，对数组的初始化还是建议使用构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> scores_[<span class="number">3</span>]; <span class="comment">// 使用下划线_与scores进行区分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数       // 数组的初始化列表</span></span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> scores[<span class="number">3</span>]) : scores_&#123;scores[<span class="number">0</span>], scores[<span class="number">1</span>], scores[<span class="number">2</span>]&#125;</span><br><span class="line">  &#123; &#125; <span class="comment">// 空的函数体，什么都不做</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">coutScores</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i : scores_) cout &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> scores[<span class="number">3</span>] = &#123;<span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>&#125;;</span><br><span class="line">  CStu stu = &#123;scores&#125;;</span><br><span class="line">  stu.<span class="built_in">coutScores</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用类型成员的初始化<br>
常量和引用类型数据必须使用初始化列表进行初始化，不能使用构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员间的引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> score_;</span><br><span class="line">  <span class="type">int</span> &amp;mark_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CStu</span>() : <span class="built_in">mark_</span>(score_) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(<span class="type">int</span> score)</span> </span>&#123; score_ = score; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setMark</span><span class="params">(<span class="type">int</span> mark)</span> </span>&#123; mark_ = mark; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">coutScore</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;score: &quot;</span> &lt;&lt; score_ &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">coutMark</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;mark: &quot;</span> &lt;&lt; mark_ &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu;</span><br><span class="line">  stu.<span class="built_in">setScore</span>(<span class="number">90</span>);</span><br><span class="line">  stu.<span class="built_in">coutScore</span>(); <span class="comment">// score: 90</span></span><br><span class="line">  stu.<span class="built_in">coutMark</span>();  <span class="comment">// mark: 90</span></span><br><span class="line"></span><br><span class="line">  stu.<span class="built_in">setMark</span>(<span class="number">80</span>);</span><br><span class="line">  stu.<span class="built_in">coutScore</span>(); <span class="comment">// score: 80</span></span><br><span class="line">  stu.<span class="built_in">coutMark</span>();  <span class="comment">// mark: 80</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用外部变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> &amp;mark_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// mark_ 间接引用外部变量 grade</span></span><br><span class="line">  <span class="comment">// grade &lt;-- score &lt;-- mark_ </span></span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> &amp;score) : <span class="built_in">mark_</span>(score) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setMark</span><span class="params">(<span class="type">int</span> mark)</span> </span>&#123; mark_ = mark; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">coutMark</span><span class="params">()</span></span>&#123; cout &lt;&lt; mark_ &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> grade = <span class="number">80</span>;</span><br><span class="line">  CStu stu = &#123;grade&#125;;</span><br><span class="line">  stu.<span class="built_in">coutMark</span>();         <span class="comment">// 80</span></span><br><span class="line">  cout &lt;&lt; grade &lt;&lt; endl;  <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line">  stu.<span class="built_in">setMark</span>(<span class="number">90</span>);</span><br><span class="line">  stu.<span class="built_in">coutMark</span>();         <span class="comment">// 90</span></span><br><span class="line">  cout &lt;&lt; grade &lt;&lt; endl;  <span class="comment">// 90</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常量成员的初始化<br>
常量和引用类型数据必须使用初始化列表进行初始化，不能使用构造函数。<br>
const成员直接传递一个值对其进行初始化即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> id_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> id) : <span class="built_in">id_</span>(id) <span class="comment">// 常量的初始化列表</span></span><br><span class="line">  &#123; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">coutId</span><span class="params">()</span> </span>&#123; cout &lt;&lt; id_ &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu = &#123;<span class="number">1000</span>&#125;;</span><br><span class="line">  stu.<span class="built_in">coutId</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结构体的初始化列表</p>
<p>结构体的初始化列表和普通变量的初始化列表一样，因为结构体变量可以像普通变量一样相互赋值，即C++允许直接把一个结构体变量通过<code>=</code>直接赋值给另一个变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Score</span></span><br><span class="line">&#123;</span><br><span class="line">  string course;</span><br><span class="line">  <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Score math_, english_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数                   // 结构体的初始化列表</span></span><br><span class="line">  <span class="built_in">CStu</span>(Score math, Score english) : math_&#123;math&#125;, <span class="built_in">english_</span>(english) &#123; &#125;</span><br><span class="line">  <span class="comment">// 输出变量</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">coutMath</span><span class="params">()</span> </span>&#123; cout &lt;&lt; math_.course &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; math_.score &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">coutEnglish</span><span class="params">()</span> </span>&#123; cout &lt;&lt; english_.course &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; english_.score &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Score math = &#123;<span class="string">&quot;Math&quot;</span>, <span class="number">80</span>&#125;;</span><br><span class="line">  Score english = &#123;<span class="string">&quot;English&quot;</span>, <span class="number">90</span>&#125;;</span><br><span class="line">  CStu stu = &#123;math, english&#125;;</span><br><span class="line">  stu.<span class="built_in">coutMath</span>();</span><br><span class="line">  stu.<span class="built_in">coutEnglish</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化列表注意事项</p>
<ul>
<li>初始化列表的初始化是在构造函数之前执行的</li>
<li>成员变量的初始化顺序只与变量的声明顺序有关，与初始化列表中的书写顺序无关</li>
<li>成员变量之间可以相互初始化，但注意要同类型+初始化顺序</li>
<li>当有多个构造构成重载关系时，初始化列表只执行所绑定的构造函数被执行的初始化列表</li>
</ul>
</li>
</ul>
<h3 id="析构函数destructor">析构函数destructor</h3>
<p>用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序将自动调用一个特殊的成员函数——析构函数。与构造函数相对，析构函数完成清理工作，因此实际上很有用。例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。如果构造函数没有new空间，那么析构函数实际上没有需要完成的任务，在这种情况下不需要显示地定义析构函数，编译器会自动生成一个什么都不做的隐式析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 数据成员</span></span><br><span class="line">  string *name_; <span class="comment">// 字符串指针</span></span><br><span class="line">  <span class="type">int</span> *scores_;  <span class="comment">// 动态数组</span></span><br><span class="line">  <span class="type">int</span> length_;   <span class="comment">// 动态数组的长度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="built_in">CStu</span>(string name, <span class="type">int</span> scores[], <span class="type">int</span> length)</span><br><span class="line">  &#123;</span><br><span class="line">    length_ = length; <span class="comment">// 普通变量初始化 </span></span><br><span class="line">    name_ = <span class="keyword">new</span> string &#123;name&#125;;    <span class="comment">// new变量空间+初始化</span></span><br><span class="line">    scores_ = <span class="keyword">new</span> <span class="type">int</span>[length] &#123;&#125;; <span class="comment">// new数组空间+初始化为0</span></span><br><span class="line">    <span class="comment">// 数组初始化赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++) scores_[i] = scores[i];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object has been created.&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">CStu</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> name_;     <span class="comment">// delete普通变量</span></span><br><span class="line">    <span class="keyword">delete</span>[] scores_; <span class="comment">// delete数组变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object has been deleted.&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数成员</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">coutCStu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; *name_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length_; i++) cout &lt;&lt; scores_[i] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> scores[] = &#123;<span class="number">80</span>, <span class="number">90</span>, <span class="number">70</span>&#125;;</span><br><span class="line">  CStu stu = &#123;<span class="string">&quot;zhangwx&quot;</span>, scores, <span class="number">3</span>&#125;;</span><br><span class="line">  stu.<span class="built_in">coutCStu</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>析构函数vs构造函数</strong>：</p>
<ul>
<li>析构函数比构造函数多一个<code>~</code>符号</li>
<li>析构函数没有参数，构造函数有参数</li>
<li>析构函数只有一个，没有函数重载（因为析构函数没有参数）；<br>
构造函数可以有多个，彼此之间构成重载关系</li>
<li>构造函数在对象定义时执行，析构函数在对象回收时执行</li>
<li>类自带默认构造函数和析构函数，它们什么都不执行</li>
</ul>
<h3 id="指针对象的创建和释放">指针对象的创建和释放</h3>
<p>当new空间时调用构造函数，delete空间时调用析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>() &#123; cout &lt;&lt; <span class="string">&quot;Object has been created.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="comment">// Destructor</span></span><br><span class="line">  ~<span class="built_in">CStu</span>() &#123; cout &lt;&lt; <span class="string">&quot;Object has been deleted.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu * stu;</span><br><span class="line">  stu = <span class="keyword">new</span> CStu; <span class="comment">// Object has been created.</span></span><br><span class="line">  <span class="keyword">delete</span> stu;     <span class="comment">// Object has been deleted.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>malloc/free与new/delete的在创建对象上的区别</strong>：</p>
<ul>
<li>new会触发构造函数，malloc不会</li>
<li>delete会触发析构函数，free不会</li>
</ul>
<h3 id="this-指针">this 指针</h3>
<p>在 C++ 中，this 指针是一个特殊的指针，它指向当前对象的实例。this 是一个隐藏的指针，可以在类的成员函数中使用，它指向当前对象实例，它的值是当前对象的内存地址。<br>
当在类的成员函数中需要用到对象实例的地址时，可以使用 this。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> age_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> age) &#123; (*<span class="keyword">this</span>).age_ = age; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">CStu* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">  <span class="function">CStu* <span class="title">older</span><span class="params">(CStu *stu)</span> </span>&#123; <span class="keyword">return</span> age_ &gt; stu-&gt;age_ ? <span class="keyword">this</span> : stu; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu1 = &#123;<span class="number">18</span>&#125;, stu2 = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">  cout &lt;&lt; stu1.<span class="built_in">getThis</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;stu1 &lt;&lt; endl; <span class="comment">// 0x393d7ffafc, 0x393d7ffafc</span></span><br><span class="line">  cout &lt;&lt; stu2.<span class="built_in">getThis</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;stu2 &lt;&lt; endl; <span class="comment">// 0x393d7ffaf8, 0x393d7ffaf8</span></span><br><span class="line">  cout &lt;&lt; stu1.<span class="built_in">older</span>(&amp;stu2) &lt;&lt; endl; <span class="comment">// 0x957adff978</span></span><br><span class="line">  cout &lt;&lt; stu2.<span class="built_in">older</span>(&amp;stu1) &lt;&lt; endl; <span class="comment">// 0x957adff978</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象数组">对象数组</h3>
<p>类似普通变量类型创建数组，以及结构体创建结构体数组，类也可以创建对象数组，下面是一个示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> age_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> age) &#123; <span class="keyword">this</span>-&gt;age_ = age; &#125;</span><br><span class="line">  <span class="comment">// Member Function</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stus[] = &#123;<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>&#125;; <span class="comment">// creates an array of 3 CStu objects</span></span><br><span class="line">  <span class="comment">// Four ways to use the array of objects</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) cout &lt;&lt; stus[i].<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) cout &lt;&lt; (stus+i)-&gt;<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) cout &lt;&lt; (*(stus+i)).<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (CStu stu : stus) cout &lt;&lt; stu.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载">运算符重载</h3>
<p>类似函数重载，C++不仅允许用户为同一作用域内的同名函数依照参数的差别指定多个定义，还允许为同一<strong>运算符</strong>根据数据的类型指定不同的操作。</p>
<h4 id="运算符重载示例">运算符重载示例</h4>
<p>下面的程序定义了一个加号<code>+</code>的重载，将同一个类的两个对象进行相加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> hours; <span class="type">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">Time</span>(<span class="type">int</span> h=<span class="number">0</span>, <span class="type">int</span> m=<span class="number">0</span>) &#123;hours=h; minutes=m;&#125;</span><br><span class="line">  <span class="comment">// Operator Overloading</span></span><br><span class="line">  Time <span class="keyword">operator</span> + (Time &amp;time)</span><br><span class="line">  &#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = <span class="keyword">this</span>-&gt;minutes + time.minutes;</span><br><span class="line">    sum.hours = <span class="keyword">this</span>-&gt;hours + time.hours + sum.minutes/<span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Display Time</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout &lt;&lt; hours &lt;&lt; <span class="string">&quot; Hours, &quot;</span> &lt;&lt; minutes &lt;&lt; <span class="string">&quot; Minutes&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Time t1 = &#123;<span class="number">3</span>, <span class="number">50</span>&#125;, t2 = &#123;<span class="number">2</span>, <span class="number">40</span>&#125;;</span><br><span class="line">  t1.<span class="built_in">display</span>(); t2.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">  Time t3 = t1 + t2;          <span class="comment">// operator notation</span></span><br><span class="line">  t3.<span class="built_in">display</span>();</span><br><span class="line">  Time t4 = t1.<span class="keyword">operator</span>+(t2); <span class="comment">// function notation</span></span><br><span class="line">  t4.<span class="built_in">display</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意加号<code>+</code>为一个二目运算符，但是上面重载运算符的定义中只有一个参数。因为对象本身是作为第一操作数(加号左侧)，其中传入的对象参数是第二操作数(加号右侧)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time CStu::<span class="keyword">operator</span>+(Time &amp;time)</span><br></pre></td></tr></table></figure>
<h4 id="能够重载的运算符">能够重载的运算符</h4>
<p>允许重载的运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双目算术运算符</span></span><br><span class="line">+(加)  -(减)  *(乘)  /(除)  %(取模)</span><br><span class="line"><span class="comment">// 关系运算符</span></span><br><span class="line">==(等于)  !=(不等于)  &lt;(小于)  &gt;(大于)  &lt;=(小于等于)  &gt;=(大于等于)</span><br><span class="line"><span class="comment">// 逻辑运算符</span></span><br><span class="line">||(逻辑或)  &amp;&amp;(逻辑与)  !(逻辑非)</span><br><span class="line"><span class="comment">// 单目运算符</span></span><br><span class="line">+(正)  -(负)  *(指针)  &amp;(取地址)</span><br><span class="line"><span class="comment">// 自增自减运算符</span></span><br><span class="line">++(自增)  --(自减)</span><br><span class="line"><span class="comment">// 位运算符</span></span><br><span class="line">|(按位或)  &amp;(按位与)  ~(按位取反)  ^(按位异或)  &lt;&lt;(左移)  &gt;&gt;(右移)</span><br><span class="line"><span class="comment">// 赋值运算符</span></span><br><span class="line">=  +=  -=  *=  /=  %=  &amp;=  |=  ^=  &lt;&lt;=  &gt;&gt;=</span><br><span class="line"><span class="comment">// 空间申请与释放</span></span><br><span class="line"><span class="keyword">new</span>  <span class="keyword">delete</span>  <span class="keyword">new</span>[]  <span class="keyword">delete</span>[]</span><br><span class="line"><span class="comment">// 其他运算符</span></span><br><span class="line">()(函数调用)  -&gt;(成员访问)  ,(逗号)  [](下标)</span><br></pre></td></tr></table></figure>
<p>不允许重载的运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.       <span class="comment">// 成员访问运算符</span></span><br><span class="line">.*  -&gt;* <span class="comment">// 成员指针访问运算符</span></span><br><span class="line">::      <span class="comment">// 域运算符</span></span><br><span class="line"><span class="keyword">sizeof</span>  <span class="comment">// 长度运算符</span></span><br><span class="line">?:      <span class="comment">// 条件运算符</span></span><br><span class="line">#       <span class="comment">// 预处理符号</span></span><br></pre></td></tr></table></figure>
<h4 id="new和delete运算符">new和delete运算符</h4>
<p><code>new</code>、<code>delete</code>、<code>new[]</code>、<code>delete[]</code>的本质是四个运算符（类似<code>+ - * /</code>）</p>
<ul>
<li>
<p><code>new</code>、<code>new[]</code>的函数原型如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span></span>;</span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span>);</span><br></pre></td></tr></table></figure>
<p>当我们使用<code>new</code>和<code>new[]</code>开辟空间时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pi = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> * pi = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>实际调用的是重载的<code>operator new()</code>和<code>operator new[]()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pi = <span class="built_in">new</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> * pi = <span class="built_in">new</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>delete</code>、<code>delete[]</code>的函数原型如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *);</span><br></pre></td></tr></table></figure>
<p>当我们使用<code>delete</code>和<code>delete[]</code>释放空间时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pi;</span><br><span class="line"><span class="keyword">delete</span> pi[];</span><br></pre></td></tr></table></figure>
<p>实际调用的是重载的<code>operator delete()</code>和<code>operator delete[]()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(pi);</span><br><span class="line"><span class="keyword">delete</span>[](pi);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-03-basic.html#_54%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-delete%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%9A%84">new和delete的实现原理-delete是如何知道释放内存的大小的</a></p>
<h4 id="友元函数与运算符重载">友元函数与运算符重载</h4>
<p>在上面运算符重载的例子中，我们定义了一个加号<code>+</code>的重载作为类<code>Time</code>的一个成员函数，使得类的两个对象可以直接使用加号<code>+</code>进行相加。<br>
现在考虑一种情况，将<code>Time</code>的对象与<code>int</code>型数据进行相加：</p>
<ul>
<li><code>Time + int</code>：当Time对象在加号+左侧，int数据在加号+右侧时，我们可以直接在类内定义类成员函数的重载运算符，将int类型作为参数。</li>
<li><code>int + Time</code>：当int数据在加号+左侧，Time对象在加号+右侧时，此时直接在类内定义重载运算符已经不能适用了。但是在类外定义非成员函数的重载运算符会导致一个新的问题，即非成员函数不能直接访问类的私有数据，这该怎么解决？</li>
</ul>
<p>此时可以用到C++的友元函数，通过让类外非成员函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> hours; <span class="type">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructor with default parameters</span></span><br><span class="line">  <span class="built_in">Time</span>(<span class="type">int</span> h=<span class="number">0</span>, <span class="type">int</span> m=<span class="number">0</span>) &#123;hours=h; minutes=m;&#125;</span><br><span class="line">  <span class="comment">// Display Time</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout &lt;&lt; hours &lt;&lt; <span class="string">&quot; Hours, &quot;</span> &lt;&lt; minutes &lt;&lt; <span class="string">&quot; Minutes&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">  <span class="comment">// Friend functions</span></span><br><span class="line">  <span class="keyword">friend</span> Time <span class="keyword">operator</span>+(Time &amp;time, <span class="type">int</span> &amp;minutes);</span><br><span class="line">  <span class="keyword">friend</span> Time <span class="keyword">operator</span>+(<span class="type">int</span> &amp;minutes, Time &amp;time);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operator Overloading</span></span><br><span class="line">Time <span class="keyword">operator</span>+(Time &amp;time, <span class="type">int</span> &amp;minutes)</span><br><span class="line">&#123;</span><br><span class="line">  Time sum;</span><br><span class="line">  sum.minutes = time.minutes + minutes;</span><br><span class="line">  sum.hours = time.hours + sum.minutes/<span class="number">60</span>;</span><br><span class="line">  sum.minutes %= <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Function Overloading</span></span><br><span class="line">Time <span class="keyword">operator</span>+(<span class="type">int</span> &amp;minutes, Time &amp;time)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> time + minutes; <span class="comment">// commutative law of addition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Time time = &#123;<span class="number">3</span>, <span class="number">50</span>&#125;; <span class="type">int</span> minutes = <span class="number">30</span>;</span><br><span class="line">  Time sum1 = time + minutes; sum1.<span class="built_in">display</span>(); <span class="comment">// 4 Hours, 20 Minutes</span></span><br><span class="line">  Time sum2 = minutes + time; sum2.<span class="built_in">display</span>(); <span class="comment">// 4 Hours, 20 Minutes</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载-运算符">重载<code>&lt;&lt;</code>运算符</h4>
<p>一个很有用的运算符重载是，可以对<code>&lt;&lt;</code>运算符进行重载，使之能与cout一起来显示对象的内容。</p>
<p>在写示例代码之前，我们需要对<code>cout</code>有个更深入的了解，来看看它是如何工作的。例如下面这条语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; x &lt;&lt; y;</span><br></pre></td></tr></table></figure>
<p>它等同于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cout &lt;&lt; x) &lt;&lt; y;</span><br></pre></td></tr></table></figure>
<p><code>cout</code>本身是一个<code>ostream</code>对象，其调用<code>ostream</code>中所定义的<code>opterator&lt;&lt;()</code>方法<code>&lt;&lt; x</code>返回一个<code>ostream</code>对象，然后这个<code>ostream</code>对象再调用<code>opterator&lt;&lt;()</code>进行下一个输出<code>&lt;&lt; y</code>。这就是<code>cout</code>所进行的操作。<br>
我们在了解<code>cout</code>输出变量的原理后，可以对<code>&lt;&lt;</code>进行运算符重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> hours; <span class="type">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">Time</span>(<span class="type">int</span> h=<span class="number">0</span>, <span class="type">int</span> m=<span class="number">0</span>) &#123;hours=h; minutes=m;&#125;</span><br><span class="line">  <span class="comment">// Friend function + Operator Overloading</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, Time &amp;time);  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operator Overloading</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, Time &amp;time)</span><br><span class="line">&#123;</span><br><span class="line">  os &lt;&lt; time.hours &lt;&lt; <span class="string">&quot; Hours, &quot;</span> &lt;&lt; time.minutes &lt;&lt; <span class="string">&quot; Minutes&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Time time = &#123;<span class="number">3</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  cout &lt;&lt; time &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载-运算符">重载<code>&gt;&gt;</code>运算符</h4>
<p>在上面重载<code>&lt;&lt;</code>运算符的基础上，我们再对<code>&gt;&gt;</code>运算符进行重载，使得类对象可以通过<code>cin &gt;&gt;</code>进行输入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> hours; <span class="type">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">Time</span>(<span class="type">int</span> h=<span class="number">0</span>, <span class="type">int</span> m=<span class="number">0</span>) &#123;hours=h; minutes=m;&#125;</span><br><span class="line">  <span class="comment">// Friend function + Operator Overloading</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, Time &amp;time);</span><br><span class="line">  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Time &amp;time);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;&lt; Operator Overloading</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, Time &amp;time)</span><br><span class="line">&#123;</span><br><span class="line">  os &lt;&lt; time.hours &lt;&lt; <span class="string">&quot; Hours, &quot;</span> &lt;&lt; time.minutes &lt;&lt; <span class="string">&quot; Minutes&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &gt;&gt; Operator Overloading</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Time &amp;time)</span><br><span class="line">&#123;</span><br><span class="line">  is &gt;&gt; time.hours &gt;&gt; time.minutes;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Time time = &#123;<span class="number">3</span>, <span class="number">50</span>&#125;;</span><br><span class="line">  cout &lt;&lt; time &lt;&lt; endl; <span class="comment">// 3 Hours, 50 Minutes</span></span><br><span class="line">  cin &gt;&gt; time;          <span class="comment">// 7 40</span></span><br><span class="line">  cout &lt;&lt; time &lt;&lt; endl; <span class="comment">// 7 Hours, 40 Minutes</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类和动态内存">类和动态内存</h2>
<h3 id="类的静态成员">类的静态成员</h3>
<p><strong>静态数据成员</strong><br>
类的静态数据成员有一个特点:无论创建了多少个对象，程序都只创建一个静态变量副本。也就是说，类的所有对象共享同一个静态成员。这对于所有类对象都具有相同值的类私有数据是非常方便的。</p>
<p>下面的程序在类中声明了一个静态数据成员<code>Count</code>，并在构造函数中对<code>Count</code>进行<code>++</code>，在析构函数中对<code>Count</code>进行<code>--</code>，用于记录该类的对象数量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string Name;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> Count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(string name)</span><br><span class="line">  &#123;</span><br><span class="line">    Name=name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Constructor Count: &quot;</span> &lt;&lt; Count &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; ++Count &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Destructor</span></span><br><span class="line">  ~<span class="built_in">CStu</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Destructor Count: &quot;</span> &lt;&lt; Count &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; --Count &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initializing static class number</span></span><br><span class="line"><span class="type">int</span> CStu::Count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu1 &#123;<span class="string">&quot;n1&quot;</span>&#125;, stu2 &#123;<span class="string">&quot;n2&quot;</span>&#125;, stu3 &#123;<span class="string">&quot;n3&quot;</span>&#125;;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;END&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Constructor Count: 0-&gt;1</span></span><br><span class="line"><span class="comment">// Constructor Count: 1-&gt;2</span></span><br><span class="line"><span class="comment">// Constructor Count: 2-&gt;3</span></span><br><span class="line"><span class="comment">// END</span></span><br><span class="line"><span class="comment">// Destructor Count: 3-&gt;2</span></span><br><span class="line"><span class="comment">// Destructor Count: 2-&gt;1</span></span><br><span class="line"><span class="comment">// Destructor Count: 1-&gt;0</span></span><br></pre></td></tr></table></figure>
<p>请注意静态成员初始化的的语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> CStu::Count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句将静态数据成员<code>Count</code>的值初始化为0。请注意，不能在类声明中初始化静态成员变量，这是因为声明只描述了如何分配内存，但并不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型<code>int</code>，并使用了作用域运算符<code>::</code>，但没有使用关键字<code>static</code>。</p>
<p>初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，这将出现多个初始化语句副本，从而引发错误。</p>
<p><strong>静态函数成员</strong><br>
可以将成员函数声明为静态的(函数声明必须包含关键字<code>static</code>，但如果函数定义是独立的，则其中不能包含关键字<code>static</code>)，这样做有两个重要的后果。<br>
首先，不能通过对象调用静态成员函数；实际上，静态成员函数甚至不能使用this指针。如果静态成员函数是在<code>public</code>部分声明的，则可以使用类名和作用域解析运算符来调用它。例如，给上面的CStu类添加一个名为HowMany()的静态成员函数，我们需要在类声明中添加如下原型/定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">HowMany</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Count;&#125;</span><br></pre></td></tr></table></figure>
<p>调用它的方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CStu::<span class="built_in">HowMany</span>();</span><br></pre></td></tr></table></figure>
<p>其次，由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员，而不能访问对象的非静态成员。例如，静态方法HowMany()可以访问静态成员Count，但不能访问非静态成员Name。</p>
<p>下面是一段完整的代码示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> Count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string *Name;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(string name) &#123;Count++; Name = <span class="keyword">new</span> string &#123;name&#125;;&#125;</span><br><span class="line">  <span class="comment">// Destructor</span></span><br><span class="line">  ~<span class="built_in">CStu</span>() &#123;Count--;&#125;</span><br><span class="line">  <span class="comment">// Static Member Function</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">HowMany</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Count;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> CStu::Count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; CStu::<span class="built_in">HowMany</span>() &lt;&lt; endl;   <span class="comment">// 0</span></span><br><span class="line">  &#123;</span><br><span class="line">    CStu stu1 &#123;<span class="string">&quot;zhang&quot;</span>&#125;; <span class="comment">// calls constructor</span></span><br><span class="line">    cout &lt;&lt; CStu::<span class="built_in">HowMany</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; CStu::<span class="built_in">HowMany</span>() &lt;&lt; endl;   <span class="comment">// 0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<p>拷贝构造函数(Copy Constructors)用于将一个已有的对象复制到新创建的对象中。它用于新建对象的初始化过程中（包括按值传递参数），而不是常规的赋值过程。</p>
<p>当创建一个新的对象时，如果传入一个已有的对象，那么会调用拷贝构造函数。</p>
<p>拷贝构造函数的原型通常如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Class_name</span>(<span class="type">const</span> Class_name &amp;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于其中的const: 如果在函数中不需要通过引用修改被引用对象（变量）的值，应该声明这个引用为const类型（只读类型），这样可以防止函数内对被引用对象的意外修改。</p>
</blockquote>
<p><strong>默认的拷贝构造函数</strong><br>
如果用户没有显示地定义拷贝构造函数，那么系统会调用默认的拷贝构造函数。默认的拷贝构造函数会逐个拷贝非静态成员（浅拷贝），复制的是成员的值。静态成员不受影响，因为它们属于整个类共有，而不是单个对象。下面的程序是个默认拷贝构造函数的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CStu</span>(string name) &#123;Name=name;&#125; <span class="comment">// Constructor</span></span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Name;&#125; <span class="comment">// Method</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu1 &#123;<span class="string">&quot;zhang&quot;</span>&#125;; <span class="comment">// calls constructor</span></span><br><span class="line">  CStu stu2 &#123;stu1&#125;;    <span class="comment">// calls default copy constructor</span></span><br><span class="line">  cout &lt;&lt; stu1.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; stu2.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认拷贝构造函数注意点：对静态成员的操作</strong><br>
如果类中包含静态数据成员，并且其值将在新对象被创建时发生变化，则应该提供一个显式的拷贝构造函数来处理对静态成员的操作。</p>
<p>下面的代码在类中显示地定义了一个拷贝构造函数，用于在对象拷贝初始化时处理静态数据成员。程序中我们声明了一个类的静态数据成员Count，用于对类实例化的对象进行计数，其值在构造函数和拷贝构造函数中自加（初始化时自加），在析构函数中自减（释放空间时自减）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> Count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string Name;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(string name)</span><br><span class="line">  &#123;</span><br><span class="line">    Name=name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Constructor Count: &quot;</span></span><br><span class="line">        &lt;&lt; Count &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; ++Count &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Copy Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(CStu &amp;stu)</span><br><span class="line">  &#123;</span><br><span class="line">    Name = stu.Name; <span class="comment">// copy</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Copy Constructor Count: &quot;</span></span><br><span class="line">        &lt;&lt; Count &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; ++Count &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Destructor</span></span><br><span class="line">  ~<span class="built_in">CStu</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Destructor Count: &quot;</span></span><br><span class="line">        &lt;&lt; Count &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; --Count &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initializing static class number</span></span><br><span class="line"><span class="type">int</span> CStu::Count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu1 &#123;<span class="string">&quot;zhang&quot;</span>&#125;; <span class="comment">// calls constructor</span></span><br><span class="line">  CStu stu2 &#123;stu1&#125;;    <span class="comment">// calls copy constructor</span></span><br><span class="line">  cout &lt;&lt; stu1.Name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; stu2.Name &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Constructor Count: 0-&gt;1</span></span><br><span class="line"><span class="comment">// Copy Constructor Count: 1-&gt;2</span></span><br><span class="line"><span class="comment">// zhang, zhang</span></span><br><span class="line"><span class="comment">// Destructor Count: 2-&gt;1</span></span><br><span class="line"><span class="comment">// Destructor Count: 1-&gt;0</span></span><br></pre></td></tr></table></figure>
<p>如果我们注释掉拷贝构造函数，让在对象拷贝初始化时调用默认的拷贝构造函数，程序的输出会变成下面这样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructor Count: 0-&gt;1</span></span><br><span class="line"><span class="comment">// zhang, zhang</span></span><br><span class="line"><span class="comment">// Destructor Count: 1-&gt;0</span></span><br><span class="line"><span class="comment">// Destructor Count: 0-&gt;-1</span></span><br></pre></td></tr></table></figure>
<p>导致-1的原因是，在拷贝初始化时程序调用的是默认的拷贝构造函数，而默认的拷贝构造函数并没有像构造函数中那样对静态数据成员Count进行自增，所以虽然我们创建了两个对象，但是Count的值只有1。在程序结束释放空间调用析构函数时，两个对象各自调用一次析构函数，所以Count的值变成-1。</p>
<p><strong>默认拷贝构造函数注意点：按值复制</strong><br>
当类的成员中有指针或者数组时（数组也可以看作指针），调用默认拷贝构造函数会导致问题，默认构造函数对指针的拷贝仅仅拷贝指针本身，即地址，而不是指针所指向的内存空间，这样的拷贝叫做<strong>浅拷贝</strong>。所以这种情况应当定义一个显示的拷贝构造函数来处理指针和数组成员的拷贝。</p>
<p>下面的程序所声明的类中包含一个指针类型的成员，并且类中并没有显示地定义拷贝构造函数，当调用系统默认的拷贝构造函数进行拷贝初始化时，新创建对象的指针Name仅仅拷贝了旧对象Name的值，两个对象的Name指针指向了同一个地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string *Name;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(string name) &#123;Name = <span class="keyword">new</span> string; *Name = name;&#125;</span><br><span class="line">  <span class="comment">// Destructor</span></span><br><span class="line">  ~<span class="built_in">CStu</span>() &#123;<span class="keyword">delete</span> Name;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu1 &#123;<span class="string">&quot;zhang&quot;</span>&#125;; <span class="comment">// calls constructor</span></span><br><span class="line">  CStu stu2 &#123;stu1&#125;;    <span class="comment">// calls copy constructor</span></span><br><span class="line">  cout &lt;&lt; *stu1.Name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *stu2.Name &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// zhang, zhang</span></span><br><span class="line">  cout &lt;&lt; stu1.Name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (stu2.Name) &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 0x18a27407ea0, 0x18a27407ea0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的默认拷贝构造函数的操作可以如下描述</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CStu</span>(CStu &amp;stu) &#123;Name = stu.Name;&#125;</span><br></pre></td></tr></table></figure>
<p>它只进行了地址的拷贝，而没有为新建的对象new一个新的string空间，再进行深度拷贝。</p>
<p>我们为这个类显示地定义一个拷贝构造函数来处理指针拷贝的问题，这样问题就得到解决了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CStu</span>(CStu &amp;stu)</span><br><span class="line">&#123;</span><br><span class="line">  Name = <span class="keyword">new</span> string;</span><br><span class="line">  *Name = *stu.Name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的赋值运算符">类的赋值运算符</h3>
<p>C++允许类对象通过赋值运算符<code>=</code>相互赋值，这是通过自动为类重载赋值运算符实现的。这种运算符的原型如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class_name &amp; Class_name::<span class="keyword">operator</span>=(<span class="type">const</span> Class_name &amp;);</span><br></pre></td></tr></table></figure>
<p>它接受一个类对象的引用，并返回一个类对象的引用。下面是一个赋值运算符重载的示例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string *Name;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(string name) &#123;Name = <span class="keyword">new</span> string &#123;name&#125;;&#125;</span><br><span class="line">  <span class="comment">// Destructor</span></span><br><span class="line">  ~<span class="built_in">CStu</span>() &#123;<span class="keyword">delete</span> Name;&#125;</span><br><span class="line">  <span class="comment">// Assignment Operator Overloading</span></span><br><span class="line">  CStu&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CStu &amp;stu)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Calling Overloaded Assignment Operator\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;stu) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// object assigned to itself</span></span><br><span class="line">    <span class="comment">// this-&gt;Name = stu.Name;       // shallow copy (DON&#x27;T)</span></span><br><span class="line">    *(<span class="keyword">this</span>-&gt;Name) = *(stu.Name);    <span class="comment">// deep copy</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu1 &#123;<span class="string">&quot;zhang&quot;</span>&#125;; <span class="comment">// calls constructor</span></span><br><span class="line">  CStu stu2 &#123;<span class="string">&quot;wang&quot;</span>&#125;;  <span class="comment">// calls constructor</span></span><br><span class="line">  cout &lt;&lt; *stu1.Name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *stu2.Name &lt;&lt; endl;</span><br><span class="line">  stu1 = stu2 = stu2;  <span class="comment">// calls overloaded assignment operator</span></span><br><span class="line">  cout &lt;&lt; *stu1.Name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *stu2.Name &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用构造函数创建类对象的时候允许不加等号，加不加等号是等价的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CStu stu1 &#123;<span class="string">&quot;zhang&quot;</span>&#125;;    <span class="comment">// calls constructor</span></span><br><span class="line">CStu stu2 = &#123;<span class="string">&quot;zhang&quot;</span>&#125;;  <span class="comment">// calls constructor</span></span><br><span class="line"><span class="comment">// CStu stu3 = &quot;zhang&quot;; // error: no suitable constructor exists</span></span><br></pre></td></tr></table></figure>
<p>在拷贝初始化时加不加等号也是等价的，调用的都是拷贝构造函数，而不是重载的赋值运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CStu stu4 &#123;stu1&#125;;   // calls copy constructor</span><br><span class="line">CStu stu5 = &#123;stu1&#125;; // calls copy constructor</span><br><span class="line">CStu stu6 = stu1;   // calls copy constructor</span><br></pre></td></tr></table></figure>
<h3 id="传入对象类型const和">传入对象类型<code>const</code>和<code>&amp;</code></h3>
<p>我们定义一个类，并为这个类定义4个名为copy的方法，这个方法要求传入一个类对象。当对象调用copy方法时，将拷贝传入对象的数据到调用对象。这4个copy方法的区别在于它们的参数类型是否包含常量声明<code>const</code>和引用声明<code>&amp;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string Name;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(string name) &#123;Name = name;&#125;</span><br><span class="line">  <span class="comment">// Copy Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">const</span> CStu &amp;stu) &#123;Name = stu.Name;&#125;</span><br><span class="line">  <span class="comment">// 4 Methods of Copying</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">copy1</span><span class="params">(CStu stu)</span> </span>&#123;Name = stu.Name;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">copy2</span><span class="params">(CStu &amp;stu)</span> </span>&#123;Name = stu.Name;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">copy3</span><span class="params">(<span class="type">const</span> CStu stu)</span> </span>&#123;Name = stu.Name;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">copy4</span><span class="params">(<span class="type">const</span> CStu &amp;stu)</span> </span>&#123;Name = stu.Name;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu1 &#123;<span class="string">&quot;zhang&quot;</span>&#125;, stu2 &#123;<span class="string">&quot;wang&quot;</span>&#125;;</span><br><span class="line">  stu1.<span class="built_in">copy1</span>(stu2);</span><br><span class="line">  stu1.<span class="built_in">copy2</span>(stu2);</span><br><span class="line">  stu1.<span class="built_in">copy3</span>(stu2);</span><br><span class="line">  stu1.<span class="built_in">copy4</span>(stu2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这四种声明的区别</p>
<ol>
<li>第一种声明会创建一个临时对象stu来接受传入的对象stu2，并调用类的拷贝构造函数对stu进行初始化，最后的操作相当于<code>stu1&lt;-(stu&lt;-stu2)</code>。</li>
<li>第二种声明会创建类CStu的一个引用stu，并使用传入对象stu2对引用stu进行初始化。这种声明没有创建新的对象，也不会调用拷贝构造函数。最后的操作相当于<code>stu1&lt;-stu2</code>。</li>
<li>第三种声明会创建一个const的临时对象stu，并使用传入的对象stu2对const对象stu进行初始化。这种声明会创建新的对象（只不过是const型的），并调用拷贝构造函数。与1的区别在于3的临时对象是const类型的，其值不能被赋值改变。最后的操作相当于<code>stu1&lt;-(stu&lt;-stu2)</code>。</li>
<li>第四种声明会创建类CStu的一个const引用stu（read-only reference），并使用传入的对象stu2对const引用进行初始化。这种声明没有创建新的对象，也不会调用拷贝构造函数。与2的区别在于4的引用是const类型的(read-only)，不能通过这个引用对原对象stu2进行赋值操作。注意原对象stu2本身并不是const的，其值可以通过stu2进行修改，只是不能通过它的const型的引用进行修改。最后的操作相当于<code>stu1&lt;-stu2</code>。</li>
</ol>
<h3 id="返回对象类型const和">返回对象类型<code>const</code>和<code>&amp;</code></h3>
<p>除了传入对象的类型依据<code>const</code>和<code>&amp;</code>可以分成4种，返回对象的类型也同样如此。下面的类依据返回类型的声明是否包含<code>const</code>和<code>&amp;</code>定义了4种copy方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string Name;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(string name) &#123;Name = name;&#125;</span><br><span class="line">  <span class="comment">// Copy Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">const</span> CStu &amp;stu) &#123;Name = stu.Name;&#125;</span><br><span class="line">  <span class="comment">// Operator Overloading</span></span><br><span class="line">  CStu&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CStu &amp;stu) &#123;Name = stu.Name; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">  <span class="comment">// Method</span></span><br><span class="line">  <span class="function">CStu <span class="title">copy1</span><span class="params">(<span class="type">const</span> CStu &amp;stu)</span> </span>&#123;Name = stu.Name; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">  <span class="function">CStu&amp; <span class="title">copy2</span><span class="params">(<span class="type">const</span> CStu &amp;stu)</span> </span>&#123;Name = stu.Name; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> CStu <span class="title">copy3</span><span class="params">(<span class="type">const</span> CStu &amp;stu)</span> </span>&#123;Name = stu.Name; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> CStu&amp; <span class="title">copy4</span><span class="params">(<span class="type">const</span> CStu &amp;stu)</span> </span>&#123;Name = stu.Name; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu1 &#123;<span class="string">&quot;zhang&quot;</span>&#125;;</span><br><span class="line">  CStu stu2 &#123;<span class="string">&quot;wang&quot;</span>&#125;;</span><br><span class="line">  CStu stu3 &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">  stu3 = stu1.<span class="built_in">copy1</span>(stu2); <span class="comment">// calls copy constructor</span></span><br><span class="line">  stu3 = stu1.<span class="built_in">copy2</span>(stu2); <span class="comment">// doesn&#x27;t call copy constructor</span></span><br><span class="line">  stu3 = stu1.<span class="built_in">copy3</span>(stu2); <span class="comment">// calls copy constructor</span></span><br><span class="line">  stu3 = stu1.<span class="built_in">copy4</span>(stu2); <span class="comment">// doesn&#x27;t call copy constructor</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这四种返回类型的区别：</p>
<ol>
<li>
<p>第一种返回类型声明将返回一个临时对象。它将创建一个临时对象，并使用<code>*this</code>（stu1）对其进行拷贝初始化，这会调用到拷贝构造函数。然后这个临时变量作为返回值又被赋值给stu3，这会调用到赋值运算符重载。</p>
</li>
<li>
<p>第二种返回类型声明将返回一个对象的引用。它将创建一个CStu的引用，并使用<code>*this</code>（stu1）对其进行初始化。这个过程没有创建新的对象，并且也不会调用拷贝构造函数。然后返回的stu1的引用又被赋值给stu3，这个过程会调用赋值运算符重载。</p>
</li>
<li>
<p>第三种返回类型声明将返回一个const的临时对象。它将创建一个const的临时对象，并使用<code>*this</code>（stu1）对其进行初始化，这会调用到拷贝构造函数。然后这个const的临时变量作为返回值又被赋值给stu3，这会调用赋值运算符重载。与1的区别在于3返回的对象是const类型的，其值不能被赋值修改。</p>
</li>
<li>
<p>第四种返回类型声明将返回一个const的对象引用（read-only reference）。它将创建一个CStu的const(read-only)的引用，并使用<code>*this</code>（stu1）对其进行初始化。这个过程没有创建新的对象，并且也不会调用拷贝构造函数。然后返回的stu1的read-only的引用又被赋值给stu3，这个过程会调用赋值运算符重载。与2的区别在于4返回的stu1的const引用是read-only的，不能通过4的返回值对它的引用对象stu1本身进行赋值修改。</p>
</li>
</ol>
<p>在连续调用中，四种返回的区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu1 &#123;<span class="string">&quot;zhang&quot;</span>&#125;;</span><br><span class="line">  CStu stu2 &#123;<span class="string">&quot;wang&quot;</span>&#125;;</span><br><span class="line">  CStu stu3 &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">  stu3.<span class="built_in">copy1</span>(stu2).<span class="built_in">copy1</span>(stu1); <span class="comment">// zhang, wang, wang</span></span><br><span class="line">  stu3.<span class="built_in">copy2</span>(stu2).<span class="built_in">copy2</span>(stu1); <span class="comment">// zhang, wang, zhang</span></span><br><span class="line">  stu3.<span class="built_in">copy3</span>(stu2).<span class="built_in">copy3</span>(stu1); <span class="comment">// error: passing &#x27;const CStu&#x27; as &#x27;this&#x27; argument discards qualifiers</span></span><br><span class="line">  stu3.<span class="built_in">copy4</span>(stu2).<span class="built_in">copy4</span>(stu1); <span class="comment">// error: passing &#x27;const CStu&#x27; as &#x27;this&#x27; argument discards qualifiers</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的调用相当于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(stu3.<span class="built_in">copy</span>(stu2)).<span class="built_in">copy</span>(stu1);</span><br></pre></td></tr></table></figure>
<ol>
<li>第一种连续调用：<code>stu3.copy1(stu2)</code>返回的是一个临时对象，再使用临时对象的copy1方法拷贝stu1，所以结果上只将stu2赋值给了stu3；</li>
<li>第二种连续调用：<code>stu3.copy2(stu2)</code>返回的是一个对象引用，并且引用的是stu3，再通过stu3的引用调用copy2方法复制stu1给stu3，所以结果上先将stu2赋值给了stu3，再将stu1赋值给stu3；</li>
<li>第三种连续调用：<code>stu3.copy3(stu2)</code>返回的是一个const的临时对象，这个const对象调用copy3方法对其值进行修改，这不被允许所以报错。</li>
<li>第四种连续调用：<code>stu3.copy4(stu2)</code>返回的是一个const的对象引用，并且引用的是stu3，然后程序试图再通过这个const引用对stu3进行修改，但这不被允许所以报错。</li>
</ol>
<h3 id="何时使用const和">何时使用<code>const</code>和<code>&amp;</code></h3>
<p>我们定义一个复数类Complex，其中的数据部分放在public下，这是为了方便观察和修改它们。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Real part and Imaginary part</span></span><br><span class="line">  <span class="type">double</span> real; <span class="type">double</span> imag;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">Complex</span>(<span class="type">double</span> r=<span class="number">0</span>, <span class="type">double</span> i=<span class="number">0</span>) &#123;real=r; imag=i;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="对象vs对象的引用">对象vs对象的引用</h4>
<p><strong>返回对象的引用</strong><br>
使用引用的常见原因是旨在提高效率，但对于何时可以采用这种方式存在一些限制。如果函数返回作为参数传递给它的对象，可以通过返回它的引用来提高其效率。因为这样不用额外创建一个新的对象。例如，假设要编写函数Max()，它返回两个Complex对象中较大的一个。该函数将以下面的方式被使用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex&amp; <span class="title">Max</span><span class="params">(Complex &amp;c1, Complex &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> modulus1 = (c1.real)*(c1.real) + (c1.imag)*(c1.imag);</span><br><span class="line">  <span class="type">double</span> modulus2 = (c2.real)*(c2.real) + (c2.imag)*(c2.imag);</span><br><span class="line">  <span class="keyword">if</span>(modulus1 &gt; modulus2)</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数返回<code>Complex&amp;</code>相比于<code>Complex</code>本身效率更高，因为它会返回c1或者c2本身（它们的引用），而不会新创建一个对象。</p>
<p><strong>返回对象</strong><br>
如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数。因此，当控制权回到调用函数时，引用指向的对象将不复存在。在这种情况下应返回对象而不是对象的引用。通常，被重载的算术运算符属于这一类。例如对加号运算符的重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(Complex &amp;c1, Complex &amp;c2)</span><br><span class="line">&#123;</span><br><span class="line">  Complex c;</span><br><span class="line">  c.real = c1.real + c2.real;</span><br><span class="line">  c.imag = c1.imag + c2.imag;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面对加号重载的实现，在函数体中定义了一个局部对象c，这个局部对象只在函数被调用时存在，当函数结束调用时会自动调用析构函数释放这个临时对象。所以我们不能返回它的引用只能返回一个新的临时对象。</p>
<h4 id="const对象vs非const对象">const对象vs非const对象</h4>
<p><strong>返回const对象</strong><br>
上面对加号的重载返回非const的<code>Complex</code>对象，这样返回非const的对象会允许一种特殊的用法，这样的用法显然是不合逻辑的，但编译器会允许这样的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 + c2 = c3;</span><br></pre></td></tr></table></figure>
<p>它实际上是先计算了<code>c1 + c2</code>并返回了一个非const的临时对象，然后将c3的值赋值给这个非const的临时对象。从结果来看c1、c2、c3的值都没有改变。</p>
<p>或者另一种情况，你错误地将注释中的代码输入成了这样，这种情况却是很常见的错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (c1 + c2 == c3)</span></span><br><span class="line"><span class="keyword">if</span> (c1 + c2 = c3)</span><br></pre></td></tr></table></figure>
<p>如果我们返回const对象，则可以让编译器对这种情况报错 <code>error: passing 'const Complex' as 'this' argument discards qualifiers</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Complex <span class="keyword">operator</span>+(Complex &amp;c1, Complex &amp;c2);</span><br></pre></td></tr></table></figure>
<p><strong>返回非const对象</strong><br>
两种常见的返回非const对象情形是，重载赋值<code>=</code>运算符以及重载与重载<code>&lt;&lt;</code>运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Member Function: Operator= Overloading</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>=(Complex &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">  real = c.real; imag = c.imag;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面三种调用是等价的，<code>c2.operator=(c3)</code>的返回值被赋值给<code>c1</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2 = c3;</span><br><span class="line">c1 = (c2 = c3);</span><br><span class="line">c1.<span class="keyword">operator</span>=(c2.<span class="keyword">operator</span>=(c3));</span><br></pre></td></tr></table></figure>
<p>为此，返回类型为对象<code>Complex</code>或者对象的引用<code>Complex&amp;</code>都是可行的；但是为了提高效率，通过使用引用，可以避免该函数在返回时调用拷贝构造函数重新创建一个对象。</p>
<p>我们这里返回值没有加const，因为我们允许这种情况，c3赋值给c1=c2的返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(c1 = c2) = c3;</span><br></pre></td></tr></table></figure>
<p>如果声明赋值运算符的重载返回const类型则不能使用这种方式。</p>
<!-- 如果要返回const对象，那么在传入参数时不能声明对象的引用，只能声明临时对象

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Complex <span class="keyword">operator</span>=(Complex c);</span><br></pre></td></tr></table></figure>
<p>如果要返回const对象并在传参时声明对象的引用，这会导致连续赋值时报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Complex <span class="keyword">operator</span>=(Complex &amp;c);</span><br><span class="line"><span class="comment">// main()</span></span><br><span class="line">c1.<span class="keyword">operator</span>=(c2.<span class="keyword">operator</span>=(c3));</span><br><span class="line"><span class="string">&quot;error: cannot bind non-const lvalue reference of type &#x27;Complex&amp;&#x27; to an rvalue of type &#x27;const Complex&#x27;&quot;</span></span><br><span class="line">c1 = c2 = c3;</span><br><span class="line"><span class="string">&quot;error: cannot bind non-const lvalue reference of type &#x27;Complex&amp;&#x27; to an rvalue of type &#x27;const Complex&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为<code>c2.operator=(c3)</code>返回一个const对象，它是一个右值，是不可寻址的；但是<code>c1.operator=()</code>的参数声明了一个对象的引用，它要接受一个左值，一个可寻址的对象，所以报错。可以将参数列表中的非const对象修改为const对象，这样可以解决这个报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Complex <span class="keyword">operator</span>=(<span class="type">const</span> Complex &amp;c);</span><br><span class="line"><span class="comment">// main()</span></span><br><span class="line">c1.<span class="keyword">operator</span>=(c2.<span class="keyword">operator</span>=(c3));</span><br><span class="line">``` --&gt;</span><br><span class="line"></span><br><span class="line">### 构造函数中使用<span class="keyword">new</span>注意事项</span><br><span class="line"></span><br><span class="line">- 如果在构造函数中使用<span class="keyword">new</span>来初始化指针成员，则应在析构函数中使用<span class="keyword">delete</span>。</span><br><span class="line">- <span class="keyword">new</span>和<span class="keyword">delete</span>必须相互兼容。`<span class="keyword">new</span>`对应于`<span class="keyword">delete</span>`，`<span class="keyword">new</span>[]`对应于`<span class="keyword">delete</span>[]`。</span><br><span class="line">- 如果有多个构造函数，则必须以相同的方式使用<span class="keyword">new</span>，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用<span class="keyword">new</span>初始化指针，而在另一个构造函数中将指针初始化为空(<span class="number">0</span>或C++<span class="number">11</span>中的<span class="literal">nullptr</span>)，这是因为<span class="built_in">delete</span>(无论是带中括号还是不带中括号)可以用于空指针。</span><br><span class="line">- 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。具体地说，复制构造函数应分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址。另外，还应该更新所有受影响的静态类成员。</span><br><span class="line">- 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。具体地说，该方法应完成这些操作:检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用。</span><br><span class="line"></span><br><span class="line">##<span class="meta"># explicit的用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explicit</span> 关键词可以关闭隐式转换，防止普通数据到类对象的隐式转换。</span><br><span class="line">如下定义一个只包含一个整型数据成员的类，定义了一个构造函数</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> CStu</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_id;</span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> id): <span class="built_in">m_id</span>(id) &#123;cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们在main中使用它，首先创建并初始化了一个id为1000的对象，我们试图修改它的id为1001，但是错误地将<code>stu.m_id = 1001</code>写成了<code>stu = 1001</code>，程序却正常地执行了！！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CStu stu = &#123;<span class="number">1000</span>&#125;;</span><br><span class="line">stu = <span class="number">1001</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的过程中，将1001（int型）赋值给stu（CStu型）实际进行了隐式转换。首先将1001转换为CStu(1001)——调用构造函数，然后将CStu(1001)赋值给stu——调用重载赋值运算符。<br>
就这个例子而言结果上没有出问题，但是下面的演示中出现了问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_id; string m_name;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="built_in">CStu</span>(<span class="type">int</span> id=<span class="number">0</span>, string name=<span class="string">&quot;None&quot;</span>): <span class="built_in">m_id</span>(id), <span class="built_in">m_name</span>(name)</span><br><span class="line">  &#123;cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>;&#125;</span><br><span class="line">  <span class="comment">// Overloaded Assignment Operator</span></span><br><span class="line">  CStu&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CStu &amp;stu)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Assignment\n&quot;</span>;</span><br><span class="line">    m_id = stu.m_id;</span><br><span class="line">    m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CStu stu = &#123;<span class="number">1000</span>, <span class="string">&quot;zhang&quot;</span>&#125;; <span class="comment">// Constructor</span></span><br><span class="line">  cout &lt;&lt; stu.m_id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu.m_name &lt;&lt; endl; <span class="comment">// 1000 zhang</span></span><br><span class="line">  stu = <span class="number">1001</span>; <span class="comment">// Constructor + Assignment</span></span><br><span class="line">  cout &lt;&lt; stu.m_id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu.m_name &lt;&lt; endl; <span class="comment">// 1001 None</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的演示中我们意图使用<code>stu.m_id = 1001</code>，将<code>1000 zhang</code>变成<code>1001 zhang</code>；但是由于疏忽写成<code>stu = 1001</code>，结果隐式调用了构造函数，<code>CStu(1001)</code>，将1001转换成了CStu临时对象，再调用赋值运算符重载，将CStu(1001)临时对象复制给stu，结果变成<code>1001 None</code>，从而造成错误。<br>
如果要避免这种错误的发生，可以在构造函数前加上<code>explicit</code>关键字，这样可以关闭隐式转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CStu</span><span class="params">(<span class="type">int</span> id=<span class="number">0</span>, string name=<span class="string">&quot;None&quot;</span>)</span>: m_id(id), m_name(name)</span></span><br></pre></td></tr></table></figure>
<p>这样我们再这样调用的时候就会报错，报错信息为<code>error: converting to 'CStu' from initializer list would use explicit constructor 'CStu::CStu(int, std::string)'</code></p>
<p>使用explicit可以防止单参数构造函数对普通的数据类型进行隐式转换，从而避免一些不必要的错误。</p>
<h2 id="类继承">类继承</h2>
<h3 id="is-a-和-has-a">is-a 和 has-a</h3>
<p>is-a-kind-of</p>
<h3 id="隐式向上转换">隐式向上转换</h3>
<p>隐式向上转换(implicit upcasting)意味着无需进行显式类型转换，就可以将基类类型的指针或引用指向派生类对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name): m_name&#123;name&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cat</span>(<span class="type">const</span> string&amp; name): <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// base class</span></span><br><span class="line">  Animal animal = &#123;<span class="string">&quot;ANIMAL&quot;</span>&#125;;</span><br><span class="line">  cout &lt;&lt; animal.<span class="built_in">getName</span>() &lt;&lt; endl; <span class="comment">// ANIMAL</span></span><br><span class="line">  <span class="comment">// object</span></span><br><span class="line">  Cat cat = &#123;<span class="string">&quot;CAT&quot;</span>&#125;;</span><br><span class="line">  cout &lt;&lt; cat.<span class="built_in">getName</span>() &lt;&lt; endl;   <span class="comment">// CAT</span></span><br><span class="line">  <span class="comment">// point</span></span><br><span class="line">  Animal *pcat = &amp;cat;</span><br><span class="line">  cout &lt;&lt; pcat-&gt;<span class="built_in">getName</span>() &lt;&lt; endl; <span class="comment">// CAT</span></span><br><span class="line">  <span class="comment">// reference</span></span><br><span class="line">  Animal &amp;rcat = cat;</span><br><span class="line">  cout &lt;&lt; rcat.<span class="built_in">getName</span>() &lt;&lt; endl;  <span class="comment">// CAT</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承类型">继承类型</h3>
<p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。<br>
我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><strong>公有继承（public）</strong><br>
当一个类继承自public修饰的基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员。</li>
<li><strong>保护继承（protected）</strong><br>
当一个类继承自protected修饰的基类时，基类的公有成员和保护成员将成为派生类的保护成员。</li>
<li><strong>私有继承（private）</strong><br>
当一个类继承自private修饰的基类时，基类的公有成员和保护成员将成为派生类的私有成员。</li>
</ul>
<p>无论是哪种继承类型，<strong>派生类都不能直接访问基类的私有成员</strong>（member is inaccessible），必须通过基类的公有方法(接口)间接访问基类的私有成员。</p>
<p>下面的表格更清晰地阐述了三种继承类型的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">公有继承</th>
<th style="text-align:center">保护继承</th>
<th style="text-align:center">私有继承</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基类公有成员变成</td>
<td style="text-align:center">派生类的公有成员</td>
<td style="text-align:center">派生类的保护成员</td>
<td style="text-align:center">派生类的私有成员</td>
</tr>
<tr>
<td style="text-align:center">基类保护成员变成</td>
<td style="text-align:center">派生类的保护成员</td>
<td style="text-align:center">派生类的保护成员</td>
<td style="text-align:center">派生类的私有成员</td>
</tr>
<tr>
<td style="text-align:center">基类私有成员变成</td>
<td style="text-align:center">只能通过基类接口访问</td>
<td style="text-align:center">只能通过基类接口访问</td>
<td style="text-align:center">只能通过基类接口访问</td>
</tr>
<tr>
<td style="text-align:center">能否隐式向上转换</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是(但只能在派生类中)</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<h3 id="访问权限">访问权限</h3>
<p>同类、子类和其它类，对三种访问修饰符修饰的类成员的访问权限<br>
（注意这里的三种访问修饰符是类内成员的访问修饰符，不是继承时基类前的访问修饰符）</p>
<table>
<thead>
<tr>
<th style="text-align:center">访问修饰符</th>
<th style="text-align:center">public</th>
<th style="text-align:center">protected</th>
<th style="text-align:center">private</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">同类</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">子类</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">其它类</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
</tr>
</tbody>
</table>
<h3 id="覆盖和虚函数">覆盖和虚函数</h3>
<p>观察下面的代码示例。这个代码定义了一个叫做Animal的基类，并由Animal衍生出两个子类Cat和Dog。基类Animal中定义了一个speak()方法，两个子类分别都对这个方法进行了重写（覆盖原本的方法）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name): m_name&#123;name&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;???\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cat</span>(<span class="type">const</span> string&amp; name): <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Miaow\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dog</span>(<span class="type">const</span> string&amp; name): <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Woof\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Animal animal = &#123;<span class="string">&quot;Whatever&quot;</span>&#125;;</span><br><span class="line">  animal.<span class="built_in">speak</span>(); <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// object</span></span><br><span class="line">  Cat cat = &#123;<span class="string">&quot;CAT&quot;</span>&#125;;</span><br><span class="line">  Dog dog = &#123;<span class="string">&quot;DOG&quot;</span>&#125;;</span><br><span class="line">  cat.<span class="built_in">speak</span>(); <span class="comment">// Miaow</span></span><br><span class="line">  dog.<span class="built_in">speak</span>(); <span class="comment">// Woof</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// point</span></span><br><span class="line">  Animal *pcat = &amp;cat;</span><br><span class="line">  Animal *pdog = &amp;dog;</span><br><span class="line">  pcat-&gt;<span class="built_in">speak</span>(); <span class="comment">// ???</span></span><br><span class="line">  pdog-&gt;<span class="built_in">speak</span>(); <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// reference</span></span><br><span class="line">  Animal &amp;rcat = cat;</span><br><span class="line">  Animal &amp;rdog = dog;</span><br><span class="line">  rcat.<span class="built_in">speak</span>(); <span class="comment">// ???</span></span><br><span class="line">  rdog.<span class="built_in">speak</span>(); <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在main中分别声明Animal、Cat和Dog的对象，分别直接使用三个对象调用speak()方法，调用的都是三个类中对应的speak()方法，即Animal::speak()、Cat::speak()、Dog::speak()；<br>
但是当我们声明两个Animal指针分别指向cat和dog，使用Animal指针调用speak()方法时，调用的都是Animal::speak()，而不是Cat::speak()和Dog::speak()；<br>
并且声明Animal类型的引用分别引用cat和dog，使用Animal类型的引用调用speak()方法时，调用的也都是Animal::speak()，而不是Cat::speak()和Dog::speak()。</p>
<p>上述引发的问题可以通过<strong>虚函数</strong>的方法来解决，我们只需要在基函数的speak()方法的声明前加上一个virtual即可声明该类的函数为虚函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name): m_name&#123;name&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br><span class="line">  <span class="comment">// virtual function</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;???\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，在使用指针和引用类型时，程序将根据所指向或引用的对象类型来调用对应的方法，而不是根据引用或指针本身的类型来选择方法版本。</p>
<p>虚方法的注意事项</p>
<ul>
<li>
<p>基类的方法一旦被声明为虚函数，那么它的子类（以及子类的子类）对应的该方法也是虚函数。上述例子中只在基类Animal中声明speak()为虚函数，在子类Cat和Dog中可以不加声明，但是还是建议加上virtual作为一种提醒。</p>
</li>
<li>
<p>为基类声明一个虚析构函数也是一种惯例，这样指针对象在释放空间时，将调用指针所指向对象类型的析构函数，而非指针类型本身对应的析构函数。</p>
</li>
</ul>
<p><strong>重写和重载</strong><br>
子类对基类的方法进行重写要求重写方法的声明与基类方法的声明有相同的特征（参数列表相同），否则便不是函数重写而是函数重载，要注意两者的区别。</p>
<h3 id="子类的构造函数">子类的构造函数</h3>
<p>由于子类不能访问基类的私有成员，所以在子类进行初始化时，不能在构造函数的函数体中对基类的私有成员进行初始化，而需要借助初始化列表调用基类的构造函数或者复制构造函数（当传入对象时）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name): m_name&#123;name&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;???\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_age;</span><br><span class="line">  string m_color;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// The constructor of the derived class</span></span><br><span class="line">  <span class="built_in">Cat</span>(<span class="type">const</span> string&amp; name, <span class="type">int</span> age, <span class="type">const</span> string&amp; color): <span class="built_in">Animal</span>(name) <span class="comment">// uses constructor of base class</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cat</span>(<span class="type">const</span> Animal&amp; obj, <span class="type">int</span> age, <span class="type">const</span> string&amp; color): <span class="built_in">Animal</span>(obj) <span class="comment">// uses implicit copy constructor of base class</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Miaow\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中，子类Cat中的有两个重载的构造函数，其中第一个在初始化列表中调用了基类的构造函数，第二个在初始化列表中调用了基类的复制构造函数。</p>
<h3 id="子类的析构函数">子类的析构函数</h3>
<p>派生类的析构函数会自动调用基类的析构函数(先派生类的析构函数再基类的析构函数)，故其自身的职责是对派生类构造函数new出的空间的进行delete。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string *m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name) &#123;m_name = <span class="keyword">new</span> string &#123;name&#125;;&#125;</span><br><span class="line">  <span class="comment">// destructor</span></span><br><span class="line">  ~<span class="built_in">Animal</span>() &#123;cout &lt;&lt; <span class="string">&quot;~Animal&quot;</span> &lt;&lt; endl; <span class="keyword">delete</span> m_name;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string *m_color;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cat</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; color): <span class="built_in">Animal</span>(name)</span><br><span class="line">  &#123;</span><br><span class="line">    m_color = <span class="keyword">new</span> string &#123;color&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// destructor</span></span><br><span class="line">  ~<span class="built_in">Cat</span>() &#123;cout &lt;&lt; <span class="string">&quot;~Cat&quot;</span> &lt;&lt; endl; <span class="keyword">delete</span> m_color;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cat cat = &#123;<span class="string">&quot;CAT&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;; <span class="comment">// ~Cat ~Animal</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="has-a">has-a</h3>
<p>通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。</p>
<h3 id="包含对象成员的类">包含对象成员的类</h3>
<p>包含string对象和valarray对象的类</p>
<h3 id="私有继承">私有继承</h3>
<h3 id="多重继承">多重继承</h3>
<h2 id="类模板">类模板</h2>
<p>类模板声明的一般形式，其中的<code>typename</code>可以换成<code>class</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; <span class="keyword">class</span> <span class="title class_">class_name</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">class</span> <span class="title class_">class_name</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个简化的Vector类模板的示例代码，其定义了一个Vector类模板，包含一个固定最大长度的数组，一个append方法用于在末尾添加元素，一个重载的方括号运算符用于取数据的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="comment">// template &lt;class Type&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123;MAX = <span class="number">100</span>&#125;;      <span class="comment">// maximum capacity</span></span><br><span class="line">  Type array[MAX];</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector</span>(): <span class="built_in">tail</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(Type item)</span> </span>&#123;array[++tail] = item;&#125;</span><br><span class="line">  Type&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;<span class="keyword">return</span> array[index];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">  vec.<span class="built_in">append</span>(<span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板重载和type-traits">模板重载和type_traits</h3>
<p>模板特化, 隐式实例化，显式实例化，显式具体化</p>
<h2 id="异常处理">异常处理</h2>
<p>单个异常的示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Harmonic mean</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a == -b)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Invalid Arguments&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;                  <span class="comment">// start of try block</span></span><br><span class="line">      z = <span class="built_in">hmean</span>(x,y);</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Harmonic mean: &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Enter next two numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// end of try block</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> *msg) <span class="comment">// start of catch block</span></span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;ReEnter two numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Bye!\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多种异常的示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_hmean</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> v1; <span class="type">double</span> v2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">bad_hmean</span>(<span class="type">double</span> a = <span class="number">0</span>, <span class="type">double</span> b = <span class="number">0</span>) : <span class="built_in">v1</span>(a), <span class="built_in">v2</span>(b)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mesg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hmean(&quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v2 &lt;&lt;<span class="string">&quot;): &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;invalid arguments: a = -b\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_gmean</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">double</span> v1; <span class="type">double</span> v2;</span><br><span class="line">  <span class="built_in">bad_gmean</span>(<span class="type">double</span> a = <span class="number">0</span>, <span class="type">double</span> b = <span class="number">0</span>) : <span class="built_in">v1</span>(a), <span class="built_in">v2</span>(b)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">mesg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;gmean() arguments should be &gt;= 0\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a == -b)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">bad_hmean</span>(a,b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">bad_gmean</span>(a,b);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(a * b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">double</span> x, y;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;                  <span class="comment">// start of try block</span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Harmonic mean: &quot;</span> &lt;&lt; <span class="built_in">hmean</span>(x,y) &lt;&lt; endl;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Geometric mean: &quot;</span> &lt;&lt; <span class="built_in">gmean</span>(x,y) &lt;&lt; endl;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// end of try block</span></span><br><span class="line">    <span class="built_in">catch</span> (bad_hmean &amp; bg) <span class="comment">// start of catch block</span></span><br><span class="line">    &#123;</span><br><span class="line">      bg.<span class="built_in">mesg</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;ReEnter two numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;                  </span><br><span class="line">    <span class="built_in">catch</span> (bad_gmean &amp; hg) </span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; hg.<span class="built_in">mesg</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Sorry, The program will terminate.\n&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">// end of catch block</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Bye!\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cmake">CMake</h2>
<p><a target="_blank" rel="noopener" href="https://cmake.org/download/">CMake/Download</a><br>
<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rR4y1E7n9/">软件构建: CMake 快速入门</a><br>
<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xa4y1R7vT/">现代C++: CMake简明教程</a></p>
<p>选择 Windows x64 Installer 版本，安装完成后使用下面命令查看环境变量是否配置正确</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>
<p>如果需要手动配置环境变量，请添加bin路径到环境变量中系统变量的Path下（For All Users）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~\CMake\bin</span><br></pre></td></tr></table></figure>
<h3 id="cmake示例1">CMake示例1</h3>
<ul>
<li>
<p>示例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// folder structure</span></span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">└── animal</span><br><span class="line">    ├── animal.h</span><br><span class="line">    └── animal.cpp</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animal/animal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string, std::cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name);</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animal/animal.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal.h&quot;</span></span></span><br><span class="line">Animal::<span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name): m_name&#123;name&#125; &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Animal::speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;???\n&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal/animal.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Animal animal = &#123;<span class="string">&quot;ANIMAL&quot;</span>&#125;;</span><br><span class="line">  animal.<span class="built_in">speak</span>(); <span class="comment">// ???</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(AnimalSound)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> main.cpp animal/animal.cpp)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用默认的MSVC进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">cmake -S .\ -B .\build_msvc <span class="comment"># 根据CmakeList.txt生成CMakeFiles</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">cmake --build .\build_msvc  <span class="comment"># 根据CMakeFiles进行编译和链接，生成可执行文件</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">.\build_msvc\Debug\AnimalSound.exe <span class="comment"># 运行生成的可执行文件</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指定使用MinGW GCC/G++进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">cmake -S .\ -B .\build_mingw -G <span class="string">&quot;MinGW Makefiles&quot;</span> <span class="comment"># 根据CmakeList.txt生成CMakeFiles</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">cmake --build .\build_mingw   <span class="comment"># 根据CMakeFiles进行编译和链接，生成可执行文件</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">.\build_mingw\AnimalSound.exe <span class="comment"># 运行生成的可执行文件</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看help</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">camke --<span class="built_in">help</span></span></span><br><span class="line">Usage</span><br><span class="line">  cmake [options] &lt;path-to-source&gt;</span><br><span class="line">  cmake [options] &lt;path-to-existing-build&gt;</span><br><span class="line">  cmake [options] -S &lt;path-to-source&gt; -B &lt;path-to-build&gt;</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">  -S &lt;path-to-source&gt;          = Explicitly specify a source directory.</span><br><span class="line">  -B &lt;path-to-build&gt;           = Explicitly specify a build directory.</span><br><span class="line">  -G &lt;generator-name&gt;          = Specify a build system generator.</span><br><span class="line">  --build &lt;dir&gt;                = Build a CMake-generated project binary tree.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>cmake --build .</code>效果与<code>make</code>等价，但可以自动识别适配当前平台的生成器，无需手动指定采用mingw32-make还是Nmake，常用于跨平台脚本中。</p>
</blockquote>
</li>
</ul>
<h3 id="cmake示例2-使用cmake文件">CMake示例2–使用cmake文件</h3>
<ul>
<li>
<p>示例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// folder structure</span></span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">└── animals</span><br><span class="line">    ├── animals.cmake</span><br><span class="line">    ├── animal.h</span><br><span class="line">    ├── animal.cpp</span><br><span class="line">    ├── cat.h</span><br><span class="line">    └── cat.cpp</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animals/animal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string, std::cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name);</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">sound</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animals/animal.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal.h&quot;</span></span></span><br><span class="line">Animal::<span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name): m_name&#123;name&#125; &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">Animal::getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Animal::sound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;???\n&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animals/cat.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cat</span>(<span class="type">const</span> string&amp; name);</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">sound</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animals/cat.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cat.h&quot;</span></span></span><br><span class="line">Cat::<span class="built_in">Cat</span>(<span class="type">const</span> string&amp; name): <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Cat::sound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Miaow\n&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animals/animal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animals/cat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Animal animal = &#123;<span class="string">&quot;ANIMAL&quot;</span>&#125;;</span><br><span class="line">  Cat cat = &#123;<span class="string">&quot;CAT&quot;</span>&#125;;</span><br><span class="line">  cout &lt;&lt; animal.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; animal.<span class="built_in">sound</span>(); <span class="comment">// ???</span></span><br><span class="line">  cout &lt;&lt; cat.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; cat.<span class="built_in">sound</span>(); <span class="comment">// Miaow</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>CMakeLists 和 cmake文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># animals/animals.cmake</span></span><br><span class="line"><span class="keyword">set</span>(animal_sources animals/animal.cpp animals/cat.cpp)</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(AnimalSound)</span><br><span class="line"><span class="comment"># add_executable($&#123;CMAKE_PROJECT_NAME&#125; main.cpp animals/animal.cpp animals/cat.cpp)</span></span><br><span class="line"><span class="keyword">include</span>(animals/animals.cmake)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> main.cpp <span class="variable">$&#123;animal_sources&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指定使用MinGW GCC/G++进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">cmake -B build_mingw -G <span class="string">&quot;MinGW Makefiles&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">cmake --build .\build_mingw\</span></span><br><span class="line"><span class="language-bash">&gt; .\build_mingw\AnimalSound.exe</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="cmake示例3-嵌套使用cmakelists-txt">CMake示例3–嵌套使用CMakeLists.txt</h3>
<ul>
<li>
<p>示例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// folder structure</span></span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">└── animals</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── animal.h</span><br><span class="line">    ├── animal.cpp</span><br><span class="line">    ├── cat.h</span><br><span class="line">    └── cat.cpp</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># animals/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(AnimalsLib animal.cpp cat.cpp)</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(AnimalSound)</span><br><span class="line"><span class="comment"># include(animals/animals.cmake)</span></span><br><span class="line"><span class="comment"># add_executable($&#123;CMAKE_PROJECT_NAME&#125; main.cpp $&#123;animal_sources&#125;)</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(animals)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> PUBLIC AnimalsLib)</span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> PUBLIC <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/animals&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="cmake语法">CMake语法</h3>
<ul>
<li>
<p>最低版本要求</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出和多行输出</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;&quot; and Output</span></span><br><span class="line"><span class="keyword">message</span>(hello world)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># MutiLine Outputs</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;hello</span></span><br><span class="line"><span class="string">world&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>([[hello</span><br><span class="line">world]])</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出CMake的版本</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the Version of CMake</span></span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;CMAKE_VERSION&#125;</span>) <span class="comment"># 3.29.0-rc1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>声明单变量</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Declare Variables</span></span><br><span class="line"><span class="keyword">set</span>(Var <span class="string">&quot;20&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;Var&#125;</span>) <span class="comment"># 20</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用set方法声明列表</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ListVar v1 v2 v3)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;ListVar&#125;</span>) <span class="comment"># v1v2v3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用list(APPEND)方法声明列表</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND MyList a1 a2 a3)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;MyList&#125;</span>) <span class="comment"># a1a2a3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取list的长度</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get the length of a list</span></span><br><span class="line"><span class="keyword">list</span>(LENGTH MyList len)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;len&#125;</span>) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取list中元素的索引</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get the index of an item</span></span><br><span class="line"><span class="keyword">list</span>(FIND MyList a1 index_a1)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;index_a1&#125;</span>) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在list末尾添加元素</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Append</span></span><br><span class="line"><span class="keyword">list</span>(APPEND MyList a4)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;MyList&#125;</span>) <span class="comment"># a1a2a3a4</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在list中插入元素</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Insert</span></span><br><span class="line"><span class="keyword">list</span>(INSERT MyList <span class="number">2</span> a0)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;MyList&#125;</span>) <span class="comment"># a1a2a0a3a4</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>反转list</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reverse</span></span><br><span class="line"><span class="keyword">list</span>(REVERSE MyList)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;MyList&#125;</span>) <span class="comment"># a4a3a0a2a1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>给list中的元素排序</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sort</span></span><br><span class="line"><span class="keyword">list</span>(SORT MyList)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;MyList&#125;</span>) <span class="comment"># a0a1a2a3a4</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对环境变量操作</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Envrionment Variables</span></span><br><span class="line"><span class="keyword">message</span>($ENV&#123;PATH&#125;)</span><br><span class="line"><span class="comment"># add path</span></span><br><span class="line"><span class="keyword">set</span>(ENV&#123;CXX&#125; <span class="string">&quot;~\\g++&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>($ENV&#123;CXX&#125;)</span><br><span class="line"><span class="comment"># unset</span></span><br><span class="line"><span class="keyword">unset</span>(ENV&#123;CXX&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>IF条件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(VAR -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(VAR <span class="keyword">GREATER</span> <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;Positive&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(VAR <span class="keyword">EQUAL</span> <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;Zero&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;Negative&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>CMake中的逻辑比较关键词</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GREATER</span> <span class="keyword">LESS</span> <span class="keyword">EQUAL</span> <span class="keyword">NOT</span> <span class="keyword">OR</span> <span class="keyword">AND</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>For循环</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(var RANGE <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">message</span>(<span class="variable">$&#123;var&#125;</span>) <span class="comment"># 0 1 2 3</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MyList a b c)</span><br><span class="line"><span class="keyword">foreach</span>(var IN LISTS MyList ITEMS D E)</span><br><span class="line">  <span class="keyword">message</span>(<span class="variable">$&#123;var&#125;</span>) <span class="comment"># a b c D E</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(L1 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)</span><br><span class="line"><span class="keyword">set</span>(L2 one two three four)</span><br><span class="line"><span class="keyword">foreach</span>(num IN ZIP_LISTS L1 L2)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;digital = $&#123;num_0&#125;, word = $&#123;num_1&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"><span class="comment"># digital = 1, word = one</span></span><br><span class="line"><span class="comment"># digital = 2, word = two</span></span><br><span class="line"><span class="comment"># digital = 3, word = three</span></span><br><span class="line"><span class="comment"># digital = 4, word = four</span></span><br><span class="line"><span class="comment"># digital = 5, word =</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(&lt;name&gt; [&lt;argument&gt;...])</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># function definition</span></span><br><span class="line"><span class="keyword">function</span>(MyFunc Arg1 Arg2)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;Func Name: $&#123;CMAKE_CURRENT_FUNCTION&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;1st Arg: $&#123;Arg1&#125;, $&#123;ARGV0&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;2nd Arg: $&#123;Arg2&#125;, $&#123;ARGV1&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>(MyFunc Arg1 Arg2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># function call</span></span><br><span class="line">MyFunc(first second)</span><br><span class="line"><span class="comment"># pass variables</span></span><br><span class="line"><span class="keyword">set</span>(var1 <span class="number">1</span>)</span><br><span class="line"><span class="keyword">set</span>(var2 <span class="number">2</span>)</span><br><span class="line">MyFunc(<span class="variable">$&#123;var1&#125;</span> <span class="variable">$&#123;var2&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>CMake中的宏</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(&lt;name&gt; [&lt;arguments&gt;...])</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(MyMacro myvar)</span><br><span class="line">  <span class="keyword">set</span>(myvar <span class="string">&quot;new value&quot;</span>) <span class="comment"># creat a new variable</span></span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;argument: $&#123;myvar&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(myvar <span class="string">&quot;my value&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;myvar: $&#123;myvar&#125;&quot;</span>)</span><br><span class="line">MyMacro(<span class="string">&quot;value&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;myvar: $&#123;myvar&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># myvar: my value</span></span><br><span class="line"><span class="comment"># argument: value</span></span><br><span class="line"><span class="comment"># myvar: new value</span></span><br></pre></td></tr></table></figure>
<p>建议不要写宏，能够阅读即可</p>
</li>
</ul>
<h2 id="第三方库的安装和管理">第三方库的安装和管理</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoft/vcpkg">Vcpkg</a></p>
<h2 id="c-标准库">C++标准库</h2>
<h2 id="c-11的新特性">C++11的新特性</h2>
<h3 id="智能指针-模板类">智能指针（模板类）</h3>
<h3 id="move操作">move操作</h3>
<h4 id="关于左值和右值的引用">关于左值和右值的引用</h4>
<ul>
<li>
<p>正确：正常的左值引用（使用一个左值str1初始化一个左值引用lref）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string &amp;lref = str; <span class="comment">// normal reference</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>错误：使用一个右值初始化一个左值引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a reference of type &quot;std::string &amp;&quot; (not const-qualified) cannot be initialized with a value of type &quot;const char [7]&quot; */</span></span><br><span class="line">string &amp;lref = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// error: cannot bind non-const lvalue reference of type &#x27;std::string&amp;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>正确：使用右值初始化一个右值引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string &amp;&amp; rref = <span class="string">&quot;hello&quot;</span>; <span class="comment">// reference to an rvalue</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>错误：使用一个左值初始化一个右值引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">/* an rvalue reference cannot be bound to an lvalue */</span></span><br><span class="line">string &amp;&amp; lref = str;</span><br><span class="line"><span class="comment">// error: cannot bind rvalue reference of type &#x27;std::string&amp;&amp;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>正确：使用<code>move</code>语句将左值（str）强制类型转化为右值，再对右值引用rref进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string &amp;&amp; lref = <span class="built_in">move</span>(str);</span><br></pre></td></tr></table></figure>
<p>但这个操作不意味着str就是右值类型了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">move</span>(str);</span><br><span class="line">string &amp;&amp; lref = str; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关于移动操作">关于移动操作</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string &amp;&amp; str2 = <span class="built_in">move</span>(str1); <span class="comment">// &lt;--</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; endl; <span class="comment">// str1: hello</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; endl; <span class="comment">// str2: hello</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;12345678901234567890&quot;</span>; <span class="comment">// size &gt; 15</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;str1 &lt;&lt; endl; <span class="comment">// str1: 12345678901234567890, 0xbd353ffdb0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;str1[0]: %x\n&quot;</span>, &amp;str1[<span class="number">0</span>]); <span class="comment">// &amp;str1[0]: a2b67fa0</span></span><br><span class="line">string str2 = <span class="built_in">move</span>(str1); <span class="comment">// &lt;--</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;str1 &lt;&lt; endl; <span class="comment">// str1: , 0xbd353ffdb0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;str2 &lt;&lt; endl; <span class="comment">// str2: 12345678901234567890, 0xbd353ffd90</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;str2[0]: %x\n&quot;</span>, &amp;str2[<span class="number">0</span>]); <span class="comment">// &amp;str2[0]: a2b67fa0</span></span><br></pre></td></tr></table></figure>
<p>在第二个代码块里面，我们将str1的“数据所有权”转移给str2，这里真正实现了移动操作，移动后str2的数据指针指向str1数据原来的地址（浅拷贝），而str1的数据指针则指向null（防止调用析构函数时对同一空间的两次释放）。另外要注意的一点是str1对象和str2对象本身的地址并不相同，只是数据指针的指向进行了移动。</p>
<blockquote>
<p>另外在string的移动构造函数的源码中，它对size&lt;=15的字符串没有调用浅拷贝，所以对于size&lt;=15的string，调用string的移动构造函数并不会指向原来数据空间的地址。</p>
</blockquote>
<p>针对对象的移动操作可以实现“真正的移动”，这是因为对应类中声明了移动构造函数；而对于普通的数据类型，只是实现了将一个右值赋值给一个左值而已，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">96</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">move</span>(a);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// a = 96</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// b = 96</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* ptr_a = <span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">96</span>);</span><br><span class="line"><span class="type">int</span>* ptr_b = <span class="built_in">move</span>(ptr_a);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr_a = &quot;</span> &lt;&lt; ptr_a &lt;&lt; endl; <span class="comment">// ptr_a = 0x160ade87fa0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr_b = &quot;</span> &lt;&lt; ptr_b &lt;&lt; endl; <span class="comment">// ptr_b = 0x160ade87fa0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*ptr_a = &quot;</span> &lt;&lt; *ptr_a &lt;&lt; endl; <span class="comment">// *ptr_a = 96</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*ptr_b = &quot;</span> &lt;&lt; *ptr_b &lt;&lt; endl; <span class="comment">// *ptr_b = 96</span></span><br></pre></td></tr></table></figure>
<h4 id="关于移动构造函数1">关于移动构造函数1</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> num_m;</span><br><span class="line">  <span class="type">int</span>* ptr_m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Number</span>(<span class="type">int</span> num = <span class="number">0</span>) &#123; <span class="comment">// constructor</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;normal constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    num_m = num;</span><br><span class="line">    ptr_m = <span class="keyword">new</span> <span class="built_in">int</span>(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Number</span>(<span class="type">const</span> Number &amp; lobj) &#123; <span class="comment">// copy constructor</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    num_m = lobj.num_m;</span><br><span class="line">    ptr_m = <span class="keyword">new</span> <span class="built_in">int</span>(*(lobj.ptr_m)); <span class="comment">// deep copy</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Number</span>(Number &amp;&amp; robj) &#123; <span class="comment">// move constructor</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    num_m = robj.num_m;</span><br><span class="line">    robj.num_m = <span class="number">0</span>;</span><br><span class="line">    ptr_m = robj.ptr_m;</span><br><span class="line">    robj.ptr_m = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Number</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr_m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Number <span class="title">one1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Number <span class="title">one2</span><span class="params">(one1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;one1: &quot;</span> &lt;&lt; one1.num_m &lt;&lt; endl; <span class="comment">// one1: 1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;one2: &quot;</span> &lt;&lt; one2.num_m &lt;&lt; endl; <span class="comment">// one2: 1</span></span><br><span class="line"><span class="comment">// normal constructor</span></span><br><span class="line"><span class="comment">// copy constructor</span></span><br><span class="line"><span class="comment">// one1: 1</span></span><br><span class="line"><span class="comment">// one2: 1</span></span><br><span class="line"><span class="comment">// destructor</span></span><br><span class="line"><span class="comment">// destructor</span></span><br><span class="line"><span class="comment">/* -------------------------------------------- */</span></span><br><span class="line"><span class="function">Number <span class="title">one1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Number <span class="title">one2</span><span class="params">(move(one1))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;one1: &quot;</span> &lt;&lt; one1.num_m &lt;&lt; endl; <span class="comment">// one1: 0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;one2: &quot;</span> &lt;&lt; one2.num_m &lt;&lt; endl; <span class="comment">// one2: 1</span></span><br><span class="line"><span class="comment">// normal constructor</span></span><br><span class="line"><span class="comment">// move constructor</span></span><br><span class="line"><span class="comment">// one1: 0</span></span><br><span class="line"><span class="comment">// one2: 1</span></span><br><span class="line"><span class="comment">// destructor</span></span><br><span class="line"><span class="comment">// destructor</span></span><br></pre></td></tr></table></figure>
<h4 id="关于移动构造函数2">关于移动构造函数2</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> num_m;</span><br><span class="line">  <span class="type">int</span>* ptr_m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Number</span>(<span class="type">int</span> num = <span class="number">0</span>) &#123; <span class="comment">// constructor</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;normal constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    num_m = num;</span><br><span class="line">    ptr_m = <span class="keyword">new</span> <span class="built_in">int</span>(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Number</span>(<span class="type">const</span> Number &amp; lobj) &#123; <span class="comment">// copy constructor</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    num_m = lobj.num_m;</span><br><span class="line">    ptr_m = <span class="keyword">new</span> <span class="built_in">int</span>(*(lobj.ptr_m)); <span class="comment">// deep copy</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Number</span>(Number &amp;&amp; robj) &#123; <span class="comment">// move constructor</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    num_m = robj.num_m;</span><br><span class="line">    robj.num_m = <span class="number">0</span>;</span><br><span class="line">    ptr_m = robj.ptr_m;</span><br><span class="line">    robj.ptr_m = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Number <span class="keyword">operator</span>+(<span class="type">const</span> Number&amp; lobj) <span class="type">const</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator overload&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">Number <span class="title">temp</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// constructor</span></span><br><span class="line">    temp.num_m = num_m + lobj.num_m;</span><br><span class="line">    *temp.ptr_m = *ptr_m + *lobj.ptr_m;</span><br><span class="line">    <span class="comment">// return move(temp);    // rvalue</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Number</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr_m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Number <span class="title">one</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="function">Number <span class="title">two</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">Number <span class="title">three</span><span class="params">(one + two)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意直接运行得到的输出结果是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">normal constructor</span><br><span class="line">normal constructor</span><br><span class="line">operator overload</span><br><span class="line">normal constructor</span><br><span class="line">temp: 0xbc6afff620</span><br><span class="line">three: 0xbc6afff620</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>
<p>这里并没有调用移动构造函数，并且我们注意到temp和three的地址是一样的，因为编译器使用返回值优化（Return Value Optimization, RVO）来避免调用拷贝构造函数或移动构造函数，那么它实际上是直接在目标对象的内存空间中构造了一个新对象，而不是通过移动构造函数来“移动”临时对象。</p>
<p>我们在g++命令后加上<code>-fno-elide-constructors</code>参数来关闭编译器优化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ .\test.cpp -o .\test -fno-elide-constructors</span><br><span class="line">.\test.exe</span><br></pre></td></tr></table></figure>
<p>此时得到的结果调用了移动构造函数，并且temp和three的地址不一样，但是它们成员ptr所指向的地址是一样的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">normal constructor</span><br><span class="line">normal constructor</span><br><span class="line">operator overload</span><br><span class="line">normal constructor</span><br><span class="line">temp: 0x1001ffcd0</span><br><span class="line">move constructor</span><br><span class="line">destructor</span><br><span class="line">three: 0x1001ffd20</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>
<h4 id="string类的简易实现">string类的简易实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// strlen, strcpy</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *cstr = <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Normal Constructor\n&quot;</span>;</span><br><span class="line">    length_m = <span class="built_in">strlen</span>(cstr);</span><br><span class="line">    str_m = <span class="keyword">new</span> <span class="type">char</span>[length_m + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str_m, cstr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">MyString</span>(<span class="type">const</span> MyString &amp;lobj)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Copy Constructor\n&quot;</span>;</span><br><span class="line">    length_m = lobj.length_m;</span><br><span class="line">    str_m = <span class="keyword">new</span> <span class="type">char</span>[length_m + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str_m, lobj.str_m); <span class="comment">// deep copy</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">MyString</span>(MyString &amp;&amp;robj)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Move Constructor\n&quot;</span>;</span><br><span class="line">    length_m = robj.length_m;</span><br><span class="line">    str_m = robj.str_m; <span class="comment">// shallow copy</span></span><br><span class="line">    robj.str_m = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">MyString</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> str_m;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> *str_m;</span><br><span class="line">  <span class="type">int</span> length_m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;    <span class="comment">// Normal Constructor</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s: %p\n&quot;</span>, str1.str_m, str1.str_m); <span class="comment">// hello: 0000015ffe897fa0</span></span><br><span class="line"></span><br><span class="line">  <span class="function">MyString <span class="title">str2</span><span class="params">(str1)</span></span>;       <span class="comment">// Copy Constructor</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s: %p\n&quot;</span>, str2.str_m, str2.str_m); <span class="comment">// hello: 0000015ffe897f30</span></span><br><span class="line"></span><br><span class="line">  <span class="function">MyString <span class="title">str3</span><span class="params">(move(str1))</span></span>; <span class="comment">// Move Constructor</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s: %p\n&quot;</span>, str1.str_m, str1.str_m); <span class="comment">// (null): 0000000000000000</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s: %p\n&quot;</span>, str3.str_m, str3.str_m); <span class="comment">// hello: 0000015ffe897fa0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意cout空指针 <code>char* temp = nullptr; cout &lt;&lt; *temp &lt;&lt; endl;</code> 会无反应，需要使用printf；以及cout字符指针 <code>cout &lt;&lt; str1.str_m &lt;&lt; endl;</code> 会输出字符串，而不是指针本身保存的内存地址；对字符指针使用取地址符 <code>cout &lt;&lt; &amp;str1.str_m &lt;&lt; endl;</code> 输出的是指针本身的地址，而不是指向内存的地址。</p>
</blockquote>
<h3 id="包装器-绑定器">包装器/绑定器</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/f593256/article/details/134593252">c++11新特性篇-可调用对象包装器, 绑定器</a></p>
<h2 id="技巧">技巧</h2>
<h3 id="assert">assert()</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// 需要包含头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// i = 100</span></span><br><span class="line">  <span class="built_in">assert</span>(i++ == <span class="number">100</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// i = 101</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(i++ != <span class="number">101</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// test: test.cpp:9: int main(): Assertion `i++ != 101&#x27; failed.</span></span><br><span class="line">  <span class="comment">// Aborted (core dumped)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://whut-zhangwx.github.io">文羊羽</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://whut-zhangwx.github.io/cpp-notebook/">https://whut-zhangwx.github.io/cpp-notebook/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://whut-zhangwx.github.io" target="_blank">文羊羽</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="/white" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-text">课程简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vscode%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">VSCode环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#use-vs-code-snippets-to-generate-main"><span class="toc-text">Use VS Code snippets to generate main()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%AE%B5%E7%AE%80%E5%8D%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%87%BA-%E6%B3%A8%E9%87%8A"><span class="toc-text">一段简单程序的输出&amp;注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-%E5%87%BD%E6%95%B0"><span class="toc-text">main 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mian%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-text">mian函数的一些特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mian%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BD%A2%E5%BC%8F"><span class="toc-text">mian函数的一些形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-text">main函数传参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cout%E5%87%BD%E6%95%B0"><span class="toc-text">cout函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#endl-n"><span class="toc-text">endl&amp;’\n’</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin%E5%87%BD%E6%95%B0"><span class="toc-text">cin函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">数字类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">常量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">数组的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char-%E6%95%B0%E7%BB%84"><span class="toc-text">char 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%8Darr-%E6%95%B0%E7%BB%84%E5%90%8D%E5%8F%96%E5%9C%B0%E5%9D%80-arr-%E6%95%B0%E7%BB%84%E9%A6%96%E5%9C%B0%E5%9D%80-arr-0"><span class="toc-text">数组名arr、数组名取地址&amp;arr、数组首地址&amp;arr[0]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">动态二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C"><span class="toc-text">关于数组越界</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">C风格字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">字符串的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-text">字符常量&amp;字符串常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">拼接字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strlen"><span class="toc-text">strlen()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-text">字符串的读取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E7%B1%BB%E5%9E%8B"><span class="toc-text">string 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-char-%E5%92%8C-string"><span class="toc-text">const char* 和 string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">字符串的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">C风格字符串的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">string类型的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char%E6%95%B0%E7%BB%84%E5%AF%B9%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">char数组对中文字符的存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">struct 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E4%B8%AD%E7%9A%84struct"><span class="toc-text">C中的struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E4%B8%AD%E7%9A%84struct"><span class="toc-text">C++中的struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%A3%B0%E6%98%8E%E5%92%8C%E5%A4%96%E9%83%A8%E5%A3%B0%E6%98%8E"><span class="toc-text">内部声明和外部声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef"><span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-text">结构体数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">结构体成员的访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#union-%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-text">union 共用体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enumerate-%E6%9E%9A%E4%B8%BE"><span class="toc-text">enumerate 枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-text">vector容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map"><span class="toc-text">unordered_map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">指针的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">数组和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">静态数组和动态数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%AE%97%E6%9C%AF"><span class="toc-text">指针算术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">指针的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%9F%E5%8F%B7%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-text">* 星号的三种用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void"><span class="toc-text">void*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E6%8C%87%E9%92%88"><span class="toc-text">const 指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E7%94%B3%E8%AF%B7"><span class="toc-text">空间申请</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E5%92%8Cfree%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">malloc和free的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%92%8Cdelete%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">new和delete的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">malloc和new的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB-vector-%E5%92%8C-array"><span class="toc-text">模板类 vector 和 array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">引用的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-text">引用作参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">引用作返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">引用与指针的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-text">交换两个变量的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8-read-only-reference"><span class="toc-text">常量引用 read-only reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%A2%9E-%E9%80%92%E5%87%8F-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">递增++递减--运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-text">while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while-%E7%AD%89%E5%BE%85"><span class="toc-text">while 等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-while"><span class="toc-text">for ⇔ while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while-%E5%BE%AA%E7%8E%AF"><span class="toc-text">do while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF-c-11"><span class="toc-text">基于范围的for循环(C++11)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break-%E5%92%8C-continue"><span class="toc-text">break 和 continue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">分支语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-else"><span class="toc-text">if&#x2F;else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">条件运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cctype%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">cctype标准库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-text">文件的读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">函数声明、函数原型和函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-text">函数传参</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">按值传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%9C%B0%E5%9D%80"><span class="toc-text">传递地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8"><span class="toc-text">传递引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84"><span class="toc-text">传递数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%BC%BA%E7%9C%81%E5%80%BC-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">参数缺省值（默认参数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-%E5%87%BD%E6%95%B0%E5%A4%9A%E6%80%81"><span class="toc-text">函数重载（函数多态）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">函数重载的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">函数重载注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-text">函数的递归调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-%E5%87%BD%E6%95%B0%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-text">函数指针（函数作参数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%87%8D%E8%BD%BD"><span class="toc-text">模板重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%8B%AC%E7%BC%96%E8%AF%91"><span class="toc-text">单独编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB"><span class="toc-text">防止头文件重复包含</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">全局变量和局部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95"><span class="toc-text">编译和调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eg-%E5%91%BD%E4%BB%A4"><span class="toc-text">基于g++命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Elaunch-json%E5%92%8Ctasks-json"><span class="toc-text">基于launch.json和tasks.json</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95"><span class="toc-text">单文件编译和调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95"><span class="toc-text">多文件编译和调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#predefined-variables-reference"><span class="toc-text">Predefined Variables Reference</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="toc-text">C++编译流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#namespace"><span class="toc-text">namespace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">命名空间的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">命名空间的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">类和对象的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">类成员的访问.&amp;-&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="toc-text">const函数成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6public-private"><span class="toc-text">访问修饰符public&amp;private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6protected"><span class="toc-text">访问修饰符protected</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0constructor"><span class="toc-text">构造函数constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%86%85%E5%A3%B0%E6%98%8E-%E5%86%85%E5%A4%96%E5%AE%9A%E4%B9%89"><span class="toc-text">类内声明+内外定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0destructor"><span class="toc-text">析构函数destructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-text">指针对象的创建和释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-text">this 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%A4%BA%E4%BE%8B"><span class="toc-text">运算符重载示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%A4%9F%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">能够重载的运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">new和delete运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">友元函数与运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">重载&lt;&lt;运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">重载&gt;&gt;运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-text">类和动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">类的静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">类的赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8Bconst%E5%92%8C"><span class="toc-text">传入对象类型const和&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8Bconst%E5%92%8C"><span class="toc-text">返回对象类型const和&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8const%E5%92%8C"><span class="toc-text">何时使用const和&amp;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1vs%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">对象vs对象的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%AF%B9%E8%B1%A1vs%E9%9D%9Econst%E5%AF%B9%E8%B1%A1"><span class="toc-text">const对象vs非const对象</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 文羊羽</div><div class="footer_custom_text">Hi, welcome to my <a href="https://whut-zhangwx.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'default' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>